/*
 * This file is part of Crypt Underworld.
 *
 * Crypt Underworld is free software: you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later
 * version.
 *
 * Crypt Underworld is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with Crypt Underworld. If not, see
 * <https://www.gnu.org/licenses/>.
 *
 * Copyright (c) 2022 ZoÃ« Sparks <zoe@milky.flowers>
 */

// This file was generated by lib.rb in gen_vulkan_util_hpp.
//
// If you need to modify this file, please edit that script rather than
// changing it by hand.

#ifndef dca51d742abb4a1e937d117355829212
#define dca51d742abb4a1e937d117355829212

#include <vulkan/vulkan.h>

#include <string>
#include <vector>
#include <algorithm>

namespace cu {
namespace vk {

/*!
 * \brief Maps to VkImageLayout. Should be safe to static_cast between.
 */
enum class ImageLayout {
    undfnd = VK_IMAGE_LAYOUT_UNDEFINED,
    gnrl = VK_IMAGE_LAYOUT_GENERAL,
    color_attchmt_optml = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    depth_stncl_attchmt_optml = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    depth_stncl_read_only_optml = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    shader_read_only_optml = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    trnsfr_src_optml = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    trnsfr_dst_optml = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    prntlzd = VK_IMAGE_LAYOUT_PREINITIALIZED,
    depth_read_only_stncl_attchmt_optml = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    depth_attchmt_stncl_read_only_optml = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    depth_attchmt_optml = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    depth_read_only_optml = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    stncl_attchmt_optml = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
    stncl_read_only_optml = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
    read_only_optml = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
    attchmt_optml = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
};

constexpr std::string img_layout_str(ImageLayout val)
{
    using enum ImageLayout;

    switch(val) {
    case undfnd:
        return "undefined";
    case gnrl:
        return "general";
    case color_attchmt_optml:
        return "color attachment optimal";
    case depth_stncl_attchmt_optml:
        return "depth/stencil attachment optimal";
    case depth_stncl_read_only_optml:
        return "depth/stencil read only optimal";
    case shader_read_only_optml:
        return "shader read only optimal";
    case trnsfr_src_optml:
        return "transfer src optimal";
    case trnsfr_dst_optml:
        return "transfer dst optimal";
    case prntlzd:
        return "preinitialized";
    case depth_read_only_stncl_attchmt_optml:
        return "depth read only stencil attachment optimal";
    case depth_attchmt_stncl_read_only_optml:
        return "depth attachment stencil read only optimal";
    case depth_attchmt_optml:
        return "depth attachment optimal";
    case depth_read_only_optml:
        return "depth read only optimal";
    case stncl_attchmt_optml:
        return "stencil attachment optimal";
    case stncl_read_only_optml:
        return "stencil read only optimal";
    case read_only_optml:
        return "read only optimal";
    case attchmt_optml:
        return "attachment optimal";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_layout_str(VkImageLayout val)
{
    return img_layout_str(static_cast<ImageLayout>(val));
}

/*!
 * \brief Maps to VkAttachmentLoadOp. Should be safe to static_cast between.
 */
enum class AttachmentLoadOp {
    lowd = VK_ATTACHMENT_LOAD_OP_LOAD,
    clear = VK_ATTACHMENT_LOAD_OP_CLEAR,
    dont_care = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
};

constexpr std::string attchmt_load_op_str(AttachmentLoadOp val)
{
    using enum AttachmentLoadOp;

    switch(val) {
    case lowd:
        return "load";
    case clear:
        return "clear";
    case dont_care:
        return "dont care";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string attchmt_load_op_str(VkAttachmentLoadOp val)
{
    return attchmt_load_op_str(static_cast<AttachmentLoadOp>(val));
}

/*!
 * \brief Maps to VkAttachmentStoreOp. Should be safe to static_cast between.
 */
enum class AttachmentStoreOp {
    store = VK_ATTACHMENT_STORE_OP_STORE,
    dont_care = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    none = VK_ATTACHMENT_STORE_OP_NONE,
};

constexpr std::string attchmt_store_op_str(AttachmentStoreOp val)
{
    using enum AttachmentStoreOp;

    switch(val) {
    case store:
        return "store";
    case dont_care:
        return "dont care";
    case none:
        return "none";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string attchmt_store_op_str(VkAttachmentStoreOp val)
{
    return attchmt_store_op_str(static_cast<AttachmentStoreOp>(val));
}

/*!
 * \brief Maps to VkImageType. Should be safe to static_cast between.
 */
enum class ImageType {
    oneD = VK_IMAGE_TYPE_1D,
    twoD = VK_IMAGE_TYPE_2D,
    threeD = VK_IMAGE_TYPE_3D,
};

constexpr std::string img_type_str(ImageType val)
{
    using enum ImageType;

    switch(val) {
    case oneD:
        return "1D";
    case twoD:
        return "2D";
    case threeD:
        return "3D";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_type_str(VkImageType val)
{
    return img_type_str(static_cast<ImageType>(val));
}

/*!
 * \brief Maps to VkImageTiling. Should be safe to static_cast between.
 */
enum class ImageTiling {
    optml = VK_IMAGE_TILING_OPTIMAL,
    linear = VK_IMAGE_TILING_LINEAR,
};

constexpr std::string img_tiling_str(ImageTiling val)
{
    using enum ImageTiling;

    switch(val) {
    case optml:
        return "optimal";
    case linear:
        return "linear";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_tiling_str(VkImageTiling val)
{
    return img_tiling_str(static_cast<ImageTiling>(val));
}

/*!
 * \brief Maps to VkImageViewType. Should be safe to static_cast between.
 */
enum class ImageViewType {
    oneD = VK_IMAGE_VIEW_TYPE_1D,
    twoD = VK_IMAGE_VIEW_TYPE_2D,
    threeD = VK_IMAGE_VIEW_TYPE_3D,
    cube = VK_IMAGE_VIEW_TYPE_CUBE,
    oneD_array = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    twoD_array = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    cube_array = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
};

constexpr std::string img_view_type_str(ImageViewType val)
{
    using enum ImageViewType;

    switch(val) {
    case oneD:
        return "1D";
    case twoD:
        return "2D";
    case threeD:
        return "3D";
    case cube:
        return "cube";
    case oneD_array:
        return "1D array";
    case twoD_array:
        return "2D array";
    case cube_array:
        return "cube array";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_view_type_str(VkImageViewType val)
{
    return img_view_type_str(static_cast<ImageViewType>(val));
}

/*!
 * \brief Maps to VkCommandBufferLevel. Should be safe to static_cast between.
 */
enum class CommandBufferLevel {
    prmry = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    scndry = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
};

constexpr std::string cmmnd_buffer_level_str(CommandBufferLevel val)
{
    using enum CommandBufferLevel;

    switch(val) {
    case prmry:
        return "primary";
    case scndry:
        return "secondary";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmmnd_buffer_level_str(VkCommandBufferLevel val)
{
    return cmmnd_buffer_level_str(static_cast<CommandBufferLevel>(val));
}

/*!
 * \brief Maps to VkComponentSwizzle. Should be safe to static_cast between.
 */
enum class ComponentSwizzle {
    idntty = VK_COMPONENT_SWIZZLE_IDENTITY,
    zero = VK_COMPONENT_SWIZZLE_ZERO,
    one = VK_COMPONENT_SWIZZLE_ONE,
    r = VK_COMPONENT_SWIZZLE_R,
    g = VK_COMPONENT_SWIZZLE_G,
    b = VK_COMPONENT_SWIZZLE_B,
    a = VK_COMPONENT_SWIZZLE_A,
};

constexpr std::string cmpnnt_swzzle_str(ComponentSwizzle val)
{
    using enum ComponentSwizzle;

    switch(val) {
    case idntty:
        return "identity";
    case zero:
        return "zero";
    case one:
        return "1";
    case r:
        return "r";
    case g:
        return "g";
    case b:
        return "b";
    case a:
        return "a";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmpnnt_swzzle_str(VkComponentSwizzle val)
{
    return cmpnnt_swzzle_str(static_cast<ComponentSwizzle>(val));
}

/*!
 * \brief Maps to VkDescriptorType. Should be safe to static_cast between.
 */
enum class DescriptorType {
    smplr = VK_DESCRIPTOR_TYPE_SAMPLER,
    cmbnd_img_smplr = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    smpld_img = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    strge_img = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    unfrm_texel_buffer = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    strge_texel_buffer = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    unfrm_buffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    strge_buffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    unfrm_buffer_dynmc = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    strge_buffer_dynmc = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    input_attchmt = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    inline_unfrm_block = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
};

constexpr std::string dscrpt_type_str(DescriptorType val)
{
    using enum DescriptorType;

    switch(val) {
    case smplr:
        return "sampler";
    case cmbnd_img_smplr:
        return "combined image sampler";
    case smpld_img:
        return "sampled image";
    case strge_img:
        return "storage image";
    case unfrm_texel_buffer:
        return "uniform texel buffer";
    case strge_texel_buffer:
        return "storage texel buffer";
    case unfrm_buffer:
        return "uniform buffer";
    case strge_buffer:
        return "storage buffer";
    case unfrm_buffer_dynmc:
        return "uniform buffer dynamic";
    case strge_buffer_dynmc:
        return "storage buffer dynamic";
    case input_attchmt:
        return "input attachment";
    case inline_unfrm_block:
        return "inline uniform block";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dscrpt_type_str(VkDescriptorType val)
{
    return dscrpt_type_str(static_cast<DescriptorType>(val));
}

/*!
 * \brief Maps to VkQueryType. Should be safe to static_cast between.
 */
enum class QueryType {
    occlsn = VK_QUERY_TYPE_OCCLUSION,
    pplne_sttstcs = VK_QUERY_TYPE_PIPELINE_STATISTICS,
    tmstmp = VK_QUERY_TYPE_TIMESTAMP,
};

constexpr std::string query_type_str(QueryType val)
{
    using enum QueryType;

    switch(val) {
    case occlsn:
        return "occlusion";
    case pplne_sttstcs:
        return "pipeline statistics";
    case tmstmp:
        return "timestamp";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string query_type_str(VkQueryType val)
{
    return query_type_str(static_cast<QueryType>(val));
}

/*!
 * \brief Maps to VkBorderColor. Should be safe to static_cast between.
 */
enum class BorderColor {
    float_trnsprt_black = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    int_trnsprt_black = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    float_opaque_black = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    int_opaque_black = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    float_opaque_white = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    int_opaque_white = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
};

constexpr std::string border_color_str(BorderColor val)
{
    using enum BorderColor;

    switch(val) {
    case float_trnsprt_black:
        return "float transparent black";
    case int_trnsprt_black:
        return "int transparent black";
    case float_opaque_black:
        return "float opaque black";
    case int_opaque_black:
        return "int opaque black";
    case float_opaque_white:
        return "float opaque white";
    case int_opaque_white:
        return "int opaque white";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string border_color_str(VkBorderColor val)
{
    return border_color_str(static_cast<BorderColor>(val));
}

/*!
 * \brief Maps to VkPipelineBindPoint. Should be safe to static_cast between.
 */
enum class PipelineBindPoint {
    grphcs = VK_PIPELINE_BIND_POINT_GRAPHICS,
    cmpte = VK_PIPELINE_BIND_POINT_COMPUTE,
};

constexpr std::string pplne_bind_point_str(PipelineBindPoint val)
{
    using enum PipelineBindPoint;

    switch(val) {
    case grphcs:
        return "graphics";
    case cmpte:
        return "compute";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_bind_point_str(VkPipelineBindPoint val)
{
    return pplne_bind_point_str(static_cast<PipelineBindPoint>(val));
}

/*!
 * \brief Maps to VkPipelineCacheHeaderVersion. Should be safe to static_cast between.
 */
enum class PipelineCacheHeaderVersion {
    one = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
};

constexpr std::string pplne_cache_header_vrsn_str(PipelineCacheHeaderVersion val)
{
    using enum PipelineCacheHeaderVersion;

    switch(val) {
    case one:
        return "1";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_cache_header_vrsn_str(VkPipelineCacheHeaderVersion val)
{
    return pplne_cache_header_vrsn_str(static_cast<PipelineCacheHeaderVersion>(val));
}

/*!
 * \brief Maps to VkPrimitiveTopology. Should be safe to static_cast between.
 */
enum class PrimitiveTopology {
    point_list = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    line_list = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    line_strip = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    trngle_list = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    trngle_strip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    trngle_fan = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    line_list_with_adjcncy = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    line_strip_with_adjcncy = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    trngle_list_with_adjcncy = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    trngle_strip_with_adjcncy = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    patch_list = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
};

constexpr std::string prmtve_tplgy_str(PrimitiveTopology val)
{
    using enum PrimitiveTopology;

    switch(val) {
    case point_list:
        return "point list";
    case line_list:
        return "line list";
    case line_strip:
        return "line strip";
    case trngle_list:
        return "triangle list";
    case trngle_strip:
        return "triangle strip";
    case trngle_fan:
        return "triangle fan";
    case line_list_with_adjcncy:
        return "line list with adjacency";
    case line_strip_with_adjcncy:
        return "line strip with adjacency";
    case trngle_list_with_adjcncy:
        return "triangle list with adjacency";
    case trngle_strip_with_adjcncy:
        return "triangle strip with adjacency";
    case patch_list:
        return "patch list";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prmtve_tplgy_str(VkPrimitiveTopology val)
{
    return prmtve_tplgy_str(static_cast<PrimitiveTopology>(val));
}

/*!
 * \brief Maps to VkSharingMode. Should be safe to static_cast between.
 */
enum class SharingMode {
    exclsv = VK_SHARING_MODE_EXCLUSIVE,
    cncrrnt = VK_SHARING_MODE_CONCURRENT,
};

constexpr std::string shrng_mode_str(SharingMode val)
{
    using enum SharingMode;

    switch(val) {
    case exclsv:
        return "exclusive";
    case cncrrnt:
        return "concurrent";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string shrng_mode_str(VkSharingMode val)
{
    return shrng_mode_str(static_cast<SharingMode>(val));
}

/*!
 * \brief Maps to VkIndexType. Should be safe to static_cast between.
 */
enum class IndexType {
    uint16 = VK_INDEX_TYPE_UINT16,
    uint32 = VK_INDEX_TYPE_UINT32,
};

constexpr std::string index_type_str(IndexType val)
{
    using enum IndexType;

    switch(val) {
    case uint16:
        return "uint16";
    case uint32:
        return "uint32";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string index_type_str(VkIndexType val)
{
    return index_type_str(static_cast<IndexType>(val));
}

/*!
 * \brief Maps to VkFilter. Should be safe to static_cast between.
 */
enum class Filter {
    nrst = VK_FILTER_NEAREST,
    linear = VK_FILTER_LINEAR,
};

constexpr std::string filter_str(Filter val)
{
    using enum Filter;

    switch(val) {
    case nrst:
        return "nearest";
    case linear:
        return "linear";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string filter_str(VkFilter val)
{
    return filter_str(static_cast<Filter>(val));
}

/*!
 * \brief Maps to VkSamplerMipmapMode. Should be safe to static_cast between.
 */
enum class SamplerMipmapMode {
    nrst = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    linear = VK_SAMPLER_MIPMAP_MODE_LINEAR,
};

constexpr std::string smplr_mipmap_mode_str(SamplerMipmapMode val)
{
    using enum SamplerMipmapMode;

    switch(val) {
    case nrst:
        return "nearest";
    case linear:
        return "linear";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smplr_mipmap_mode_str(VkSamplerMipmapMode val)
{
    return smplr_mipmap_mode_str(static_cast<SamplerMipmapMode>(val));
}

/*!
 * \brief Maps to VkSamplerAddressMode. Should be safe to static_cast between.
 */
enum class SamplerAddressMode {
    repeat = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    mrrrd_repeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    clamp_to_edge = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    clamp_to_border = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    mirror_clamp_to_edge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
};

constexpr std::string smplr_addrss_mode_str(SamplerAddressMode val)
{
    using enum SamplerAddressMode;

    switch(val) {
    case repeat:
        return "repeat";
    case mrrrd_repeat:
        return "mirrored repeat";
    case clamp_to_edge:
        return "clamp to edge";
    case clamp_to_border:
        return "clamp to border";
    case mirror_clamp_to_edge:
        return "mirror clamp to edge";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smplr_addrss_mode_str(VkSamplerAddressMode val)
{
    return smplr_addrss_mode_str(static_cast<SamplerAddressMode>(val));
}

/*!
 * \brief Maps to VkCompareOp. Should be safe to static_cast between.
 */
enum class CompareOp {
    never = VK_COMPARE_OP_NEVER,
    less = VK_COMPARE_OP_LESS,
    equal = VK_COMPARE_OP_EQUAL,
    less_or_equal = VK_COMPARE_OP_LESS_OR_EQUAL,
    grtr = VK_COMPARE_OP_GREATER,
    not_equal = VK_COMPARE_OP_NOT_EQUAL,
    grtr_or_equal = VK_COMPARE_OP_GREATER_OR_EQUAL,
    always = VK_COMPARE_OP_ALWAYS,
};

constexpr std::string cmpre_op_str(CompareOp val)
{
    using enum CompareOp;

    switch(val) {
    case never:
        return "never";
    case less:
        return "less";
    case equal:
        return "equal";
    case less_or_equal:
        return "less or equal";
    case grtr:
        return "greater";
    case not_equal:
        return "not equal";
    case grtr_or_equal:
        return "greater or equal";
    case always:
        return "always";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmpre_op_str(VkCompareOp val)
{
    return cmpre_op_str(static_cast<CompareOp>(val));
}

/*!
 * \brief Maps to VkPolygonMode. Should be safe to static_cast between.
 */
enum class PolygonMode {
    fill = VK_POLYGON_MODE_FILL,
    line = VK_POLYGON_MODE_LINE,
    point = VK_POLYGON_MODE_POINT,
};

constexpr std::string plygn_mode_str(PolygonMode val)
{
    using enum PolygonMode;

    switch(val) {
    case fill:
        return "fill";
    case line:
        return "line";
    case point:
        return "point";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string plygn_mode_str(VkPolygonMode val)
{
    return plygn_mode_str(static_cast<PolygonMode>(val));
}

/*!
 * \brief Maps to VkFrontFace. Should be safe to static_cast between.
 */
enum class FrontFace {
    cntr_clckws = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    clckws = VK_FRONT_FACE_CLOCKWISE,
};

constexpr std::string front_face_str(FrontFace val)
{
    using enum FrontFace;

    switch(val) {
    case cntr_clckws:
        return "counter clockwise";
    case clckws:
        return "clockwise";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string front_face_str(VkFrontFace val)
{
    return front_face_str(static_cast<FrontFace>(val));
}

/*!
 * \brief Maps to VkBlendFactor. Should be safe to static_cast between.
 */
enum class BlendFactor {
    zero = VK_BLEND_FACTOR_ZERO,
    one = VK_BLEND_FACTOR_ONE,
    src_color = VK_BLEND_FACTOR_SRC_COLOR,
    one_minus_src_color = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    dst_color = VK_BLEND_FACTOR_DST_COLOR,
    one_minus_dst_color = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    src_alpha = VK_BLEND_FACTOR_SRC_ALPHA,
    one_minus_src_alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    dst_alpha = VK_BLEND_FACTOR_DST_ALPHA,
    one_minus_dst_alpha = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    cnstnt_color = VK_BLEND_FACTOR_CONSTANT_COLOR,
    one_minus_cnstnt_color = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    cnstnt_alpha = VK_BLEND_FACTOR_CONSTANT_ALPHA,
    one_minus_cnstnt_alpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    src_alpha_strte = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    src1_color = VK_BLEND_FACTOR_SRC1_COLOR,
    one_minus_src1_color = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    src1_alpha = VK_BLEND_FACTOR_SRC1_ALPHA,
    one_minus_src1_alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
};

constexpr std::string blend_factor_str(BlendFactor val)
{
    using enum BlendFactor;

    switch(val) {
    case zero:
        return "zero";
    case one:
        return "1";
    case src_color:
        return "src color";
    case one_minus_src_color:
        return "1 minus src color";
    case dst_color:
        return "dst color";
    case one_minus_dst_color:
        return "1 minus dst color";
    case src_alpha:
        return "src alpha";
    case one_minus_src_alpha:
        return "1 minus src alpha";
    case dst_alpha:
        return "dst alpha";
    case one_minus_dst_alpha:
        return "1 minus dst alpha";
    case cnstnt_color:
        return "constant color";
    case one_minus_cnstnt_color:
        return "1 minus constant color";
    case cnstnt_alpha:
        return "constant alpha";
    case one_minus_cnstnt_alpha:
        return "1 minus constant alpha";
    case src_alpha_strte:
        return "src alpha saturate";
    case src1_color:
        return "src1 color";
    case one_minus_src1_color:
        return "1 minus src1 color";
    case src1_alpha:
        return "src1 alpha";
    case one_minus_src1_alpha:
        return "1 minus src1 alpha";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string blend_factor_str(VkBlendFactor val)
{
    return blend_factor_str(static_cast<BlendFactor>(val));
}

/*!
 * \brief Maps to VkBlendOp. Should be safe to static_cast between.
 */
enum class BlendOp {
    add = VK_BLEND_OP_ADD,
    sbtrct = VK_BLEND_OP_SUBTRACT,
    rvrse_sbtrct = VK_BLEND_OP_REVERSE_SUBTRACT,
    min = VK_BLEND_OP_MIN,
    max = VK_BLEND_OP_MAX,
};

constexpr std::string blend_op_str(BlendOp val)
{
    using enum BlendOp;

    switch(val) {
    case add:
        return "add";
    case sbtrct:
        return "subtract";
    case rvrse_sbtrct:
        return "reverse subtract";
    case min:
        return "min";
    case max:
        return "max";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string blend_op_str(VkBlendOp val)
{
    return blend_op_str(static_cast<BlendOp>(val));
}

/*!
 * \brief Maps to VkStencilOp. Should be safe to static_cast between.
 */
enum class StencilOp {
    keep = VK_STENCIL_OP_KEEP,
    zero = VK_STENCIL_OP_ZERO,
    rplce = VK_STENCIL_OP_REPLACE,
    incrmnt_and_clamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    dcrmnt_and_clamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    invert = VK_STENCIL_OP_INVERT,
    incrmnt_and_wrap = VK_STENCIL_OP_INCREMENT_AND_WRAP,
    dcrmnt_and_wrap = VK_STENCIL_OP_DECREMENT_AND_WRAP,
};

constexpr std::string stncl_op_str(StencilOp val)
{
    using enum StencilOp;

    switch(val) {
    case keep:
        return "keep";
    case zero:
        return "zero";
    case rplce:
        return "replace";
    case incrmnt_and_clamp:
        return "increment and clamp";
    case dcrmnt_and_clamp:
        return "decrement and clamp";
    case invert:
        return "invert";
    case incrmnt_and_wrap:
        return "increment and wrap";
    case dcrmnt_and_wrap:
        return "decrement and wrap";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string stncl_op_str(VkStencilOp val)
{
    return stncl_op_str(static_cast<StencilOp>(val));
}

/*!
 * \brief Maps to VkLogicOp. Should be safe to static_cast between.
 */
enum class LogicOp {
    clear = VK_LOGIC_OP_CLEAR,
    aand = VK_LOGIC_OP_AND,
    and_rvrse = VK_LOGIC_OP_AND_REVERSE,
    copy = VK_LOGIC_OP_COPY,
    and_invrtd = VK_LOGIC_OP_AND_INVERTED,
    no_op = VK_LOGIC_OP_NO_OP,
    xorr = VK_LOGIC_OP_XOR,
    orr = VK_LOGIC_OP_OR,
    nor = VK_LOGIC_OP_NOR,
    eqvlnt = VK_LOGIC_OP_EQUIVALENT,
    invert = VK_LOGIC_OP_INVERT,
    or_rvrse = VK_LOGIC_OP_OR_REVERSE,
    copy_invrtd = VK_LOGIC_OP_COPY_INVERTED,
    or_invrtd = VK_LOGIC_OP_OR_INVERTED,
    nand = VK_LOGIC_OP_NAND,
    set = VK_LOGIC_OP_SET,
};

constexpr std::string logic_op_str(LogicOp val)
{
    using enum LogicOp;

    switch(val) {
    case clear:
        return "clear";
    case aand:
        return "and";
    case and_rvrse:
        return "and reverse";
    case copy:
        return "copy";
    case and_invrtd:
        return "and inverted";
    case no_op:
        return "no op";
    case xorr:
        return "xor";
    case orr:
        return "or";
    case nor:
        return "nor";
    case eqvlnt:
        return "equivalent";
    case invert:
        return "invert";
    case or_rvrse:
        return "or reverse";
    case copy_invrtd:
        return "copy inverted";
    case or_invrtd:
        return "or inverted";
    case nand:
        return "nand";
    case set:
        return "set";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string logic_op_str(VkLogicOp val)
{
    return logic_op_str(static_cast<LogicOp>(val));
}

/*!
 * \brief Maps to VkInternalAllocationType. Should be safe to static_cast between.
 */
enum class InternalAllocationType {
    exctbl = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
};

constexpr std::string intrnl_allctn_type_str(InternalAllocationType val)
{
    using enum InternalAllocationType;

    switch(val) {
    case exctbl:
        return "executable";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string intrnl_allctn_type_str(VkInternalAllocationType val)
{
    return intrnl_allctn_type_str(static_cast<InternalAllocationType>(val));
}

/*!
 * \brief Maps to VkSystemAllocationScope. Should be safe to static_cast between.
 */
enum class SystemAllocationScope {
    cmmnd = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    object = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    cache = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    device = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    instnc = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
};

constexpr std::string system_allctn_scope_str(SystemAllocationScope val)
{
    using enum SystemAllocationScope;

    switch(val) {
    case cmmnd:
        return "command";
    case object:
        return "object";
    case cache:
        return "cache";
    case device:
        return "device";
    case instnc:
        return "instance";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string system_allctn_scope_str(VkSystemAllocationScope val)
{
    return system_allctn_scope_str(static_cast<SystemAllocationScope>(val));
}

/*!
 * \brief Maps to VkPhysicalDeviceType. Should be safe to static_cast between.
 */
enum class PhysicalDeviceType {
    other = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    intgrtd_gpu = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    dscrte_gpu = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    vrtl_gpu = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    cpu = VK_PHYSICAL_DEVICE_TYPE_CPU,
};

constexpr std::string physcl_device_type_str(PhysicalDeviceType val)
{
    using enum PhysicalDeviceType;

    switch(val) {
    case other:
        return "other";
    case intgrtd_gpu:
        return "integrated gpu";
    case dscrte_gpu:
        return "discrete gpu";
    case vrtl_gpu:
        return "virtual gpu";
    case cpu:
        return "cpu";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string physcl_device_type_str(VkPhysicalDeviceType val)
{
    return physcl_device_type_str(static_cast<PhysicalDeviceType>(val));
}

/*!
 * \brief Maps to VkVertexInputRate. Should be safe to static_cast between.
 */
enum class VertexInputRate {
    vertex = VK_VERTEX_INPUT_RATE_VERTEX,
    instnc = VK_VERTEX_INPUT_RATE_INSTANCE,
};

constexpr std::string vertex_input_rate_str(VertexInputRate val)
{
    using enum VertexInputRate;

    switch(val) {
    case vertex:
        return "vertex";
    case instnc:
        return "instance";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string vertex_input_rate_str(VkVertexInputRate val)
{
    return vertex_input_rate_str(static_cast<VertexInputRate>(val));
}

/*!
 * \brief Maps to VkFormat. Should be safe to static_cast between.
 */
enum class Format {
    undfnd = VK_FORMAT_UNDEFINED,
    r4g4_unorm_pack8 = VK_FORMAT_R4G4_UNORM_PACK8,
    r4g4b4a4_unorm_pack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    b4g4r4a4_unorm_pack16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    r5g6b5_unorm_pack16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
    b5g6r5_unorm_pack16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
    r5g5b5a1_unorm_pack16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    b5g5r5a1_unorm_pack16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    a1r5g5b5_unorm_pack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    r8_unorm = VK_FORMAT_R8_UNORM,
    r8_snorm = VK_FORMAT_R8_SNORM,
    r8_uscld = VK_FORMAT_R8_USCALED,
    r8_sscld = VK_FORMAT_R8_SSCALED,
    r8_uint = VK_FORMAT_R8_UINT,
    r8_sint = VK_FORMAT_R8_SINT,
    r8_srgb = VK_FORMAT_R8_SRGB,
    r8g8_unorm = VK_FORMAT_R8G8_UNORM,
    r8g8_snorm = VK_FORMAT_R8G8_SNORM,
    r8g8_uscld = VK_FORMAT_R8G8_USCALED,
    r8g8_sscld = VK_FORMAT_R8G8_SSCALED,
    r8g8_uint = VK_FORMAT_R8G8_UINT,
    r8g8_sint = VK_FORMAT_R8G8_SINT,
    r8g8_srgb = VK_FORMAT_R8G8_SRGB,
    r8g8b8_unorm = VK_FORMAT_R8G8B8_UNORM,
    r8g8b8_snorm = VK_FORMAT_R8G8B8_SNORM,
    r8g8b8_uscld = VK_FORMAT_R8G8B8_USCALED,
    r8g8b8_sscld = VK_FORMAT_R8G8B8_SSCALED,
    r8g8b8_uint = VK_FORMAT_R8G8B8_UINT,
    r8g8b8_sint = VK_FORMAT_R8G8B8_SINT,
    r8g8b8_srgb = VK_FORMAT_R8G8B8_SRGB,
    b8g8r8_unorm = VK_FORMAT_B8G8R8_UNORM,
    b8g8r8_snorm = VK_FORMAT_B8G8R8_SNORM,
    b8g8r8_uscld = VK_FORMAT_B8G8R8_USCALED,
    b8g8r8_sscld = VK_FORMAT_B8G8R8_SSCALED,
    b8g8r8_uint = VK_FORMAT_B8G8R8_UINT,
    b8g8r8_sint = VK_FORMAT_B8G8R8_SINT,
    b8g8r8_srgb = VK_FORMAT_B8G8R8_SRGB,
    r8g8b8a8_unorm = VK_FORMAT_R8G8B8A8_UNORM,
    r8g8b8a8_snorm = VK_FORMAT_R8G8B8A8_SNORM,
    r8g8b8a8_uscld = VK_FORMAT_R8G8B8A8_USCALED,
    r8g8b8a8_sscld = VK_FORMAT_R8G8B8A8_SSCALED,
    r8g8b8a8_uint = VK_FORMAT_R8G8B8A8_UINT,
    r8g8b8a8_sint = VK_FORMAT_R8G8B8A8_SINT,
    r8g8b8a8_srgb = VK_FORMAT_R8G8B8A8_SRGB,
    b8g8r8a8_unorm = VK_FORMAT_B8G8R8A8_UNORM,
    b8g8r8a8_snorm = VK_FORMAT_B8G8R8A8_SNORM,
    b8g8r8a8_uscld = VK_FORMAT_B8G8R8A8_USCALED,
    b8g8r8a8_sscld = VK_FORMAT_B8G8R8A8_SSCALED,
    b8g8r8a8_uint = VK_FORMAT_B8G8R8A8_UINT,
    b8g8r8a8_sint = VK_FORMAT_B8G8R8A8_SINT,
    b8g8r8a8_srgb = VK_FORMAT_B8G8R8A8_SRGB,
    a8b8g8r8_unorm_pack32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    a8b8g8r8_snorm_pack32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    a8b8g8r8_uscld_pack32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    a8b8g8r8_sscld_pack32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    a8b8g8r8_uint_pack32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
    a8b8g8r8_sint_pack32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
    a8b8g8r8_srgb_pack32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    a2r10g10b10_unorm_pack32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    a2r10g10b10_snorm_pack32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    a2r10g10b10_uscld_pack32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    a2r10g10b10_sscld_pack32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    a2r10g10b10_uint_pack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
    a2r10g10b10_sint_pack32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
    a2b10g10r10_unorm_pack32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    a2b10g10r10_snorm_pack32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    a2b10g10r10_uscld_pack32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    a2b10g10r10_sscld_pack32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    a2b10g10r10_uint_pack32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
    a2b10g10r10_sint_pack32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
    r16_unorm = VK_FORMAT_R16_UNORM,
    r16_snorm = VK_FORMAT_R16_SNORM,
    r16_uscld = VK_FORMAT_R16_USCALED,
    r16_sscld = VK_FORMAT_R16_SSCALED,
    r16_uint = VK_FORMAT_R16_UINT,
    r16_sint = VK_FORMAT_R16_SINT,
    r16_sfloat = VK_FORMAT_R16_SFLOAT,
    r16g16_unorm = VK_FORMAT_R16G16_UNORM,
    r16g16_snorm = VK_FORMAT_R16G16_SNORM,
    r16g16_uscld = VK_FORMAT_R16G16_USCALED,
    r16g16_sscld = VK_FORMAT_R16G16_SSCALED,
    r16g16_uint = VK_FORMAT_R16G16_UINT,
    r16g16_sint = VK_FORMAT_R16G16_SINT,
    r16g16_sfloat = VK_FORMAT_R16G16_SFLOAT,
    r16g16b16_unorm = VK_FORMAT_R16G16B16_UNORM,
    r16g16b16_snorm = VK_FORMAT_R16G16B16_SNORM,
    r16g16b16_uscld = VK_FORMAT_R16G16B16_USCALED,
    r16g16b16_sscld = VK_FORMAT_R16G16B16_SSCALED,
    r16g16b16_uint = VK_FORMAT_R16G16B16_UINT,
    r16g16b16_sint = VK_FORMAT_R16G16B16_SINT,
    r16g16b16_sfloat = VK_FORMAT_R16G16B16_SFLOAT,
    r16g16b16a16_unorm = VK_FORMAT_R16G16B16A16_UNORM,
    r16g16b16a16_snorm = VK_FORMAT_R16G16B16A16_SNORM,
    r16g16b16a16_uscld = VK_FORMAT_R16G16B16A16_USCALED,
    r16g16b16a16_sscld = VK_FORMAT_R16G16B16A16_SSCALED,
    r16g16b16a16_uint = VK_FORMAT_R16G16B16A16_UINT,
    r16g16b16a16_sint = VK_FORMAT_R16G16B16A16_SINT,
    r16g16b16a16_sfloat = VK_FORMAT_R16G16B16A16_SFLOAT,
    r32_uint = VK_FORMAT_R32_UINT,
    r32_sint = VK_FORMAT_R32_SINT,
    r32_sfloat = VK_FORMAT_R32_SFLOAT,
    r32g32_uint = VK_FORMAT_R32G32_UINT,
    r32g32_sint = VK_FORMAT_R32G32_SINT,
    r32g32_sfloat = VK_FORMAT_R32G32_SFLOAT,
    r32g32b32_uint = VK_FORMAT_R32G32B32_UINT,
    r32g32b32_sint = VK_FORMAT_R32G32B32_SINT,
    r32g32b32_sfloat = VK_FORMAT_R32G32B32_SFLOAT,
    r32g32b32a32_uint = VK_FORMAT_R32G32B32A32_UINT,
    r32g32b32a32_sint = VK_FORMAT_R32G32B32A32_SINT,
    r32g32b32a32_sfloat = VK_FORMAT_R32G32B32A32_SFLOAT,
    r64_uint = VK_FORMAT_R64_UINT,
    r64_sint = VK_FORMAT_R64_SINT,
    r64_sfloat = VK_FORMAT_R64_SFLOAT,
    r64g64_uint = VK_FORMAT_R64G64_UINT,
    r64g64_sint = VK_FORMAT_R64G64_SINT,
    r64g64_sfloat = VK_FORMAT_R64G64_SFLOAT,
    r64g64b64_uint = VK_FORMAT_R64G64B64_UINT,
    r64g64b64_sint = VK_FORMAT_R64G64B64_SINT,
    r64g64b64_sfloat = VK_FORMAT_R64G64B64_SFLOAT,
    r64g64b64a64_uint = VK_FORMAT_R64G64B64A64_UINT,
    r64g64b64a64_sint = VK_FORMAT_R64G64B64A64_SINT,
    r64g64b64a64_sfloat = VK_FORMAT_R64G64B64A64_SFLOAT,
    b10g11_ufloat_pack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    e5b9g9_ufloat_pack32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    d16_unorm = VK_FORMAT_D16_UNORM,
    x8_d24_unorm_pack32 = VK_FORMAT_X8_D24_UNORM_PACK32,
    d32_sfloat = VK_FORMAT_D32_SFLOAT,
    s8_uint = VK_FORMAT_S8_UINT,
    d16_unorm_s8_uint = VK_FORMAT_D16_UNORM_S8_UINT,
    d24_unorm_s8_uint = VK_FORMAT_D24_UNORM_S8_UINT,
    d32_sfloat_s8_uint = VK_FORMAT_D32_SFLOAT_S8_UINT,
    bc1_rgb_unorm_block = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    bc1_rgb_srgb_block = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    bc1_rgba_unorm_block = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    bc1_rgba_srgb_block = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    bc2_unorm_block = VK_FORMAT_BC2_UNORM_BLOCK,
    bc2_srgb_block = VK_FORMAT_BC2_SRGB_BLOCK,
    bc3_unorm_block = VK_FORMAT_BC3_UNORM_BLOCK,
    bc3_srgb_block = VK_FORMAT_BC3_SRGB_BLOCK,
    bc4_unorm_block = VK_FORMAT_BC4_UNORM_BLOCK,
    bc4_snorm_block = VK_FORMAT_BC4_SNORM_BLOCK,
    bc5_unorm_block = VK_FORMAT_BC5_UNORM_BLOCK,
    bc5_snorm_block = VK_FORMAT_BC5_SNORM_BLOCK,
    bc6h_ufloat_block = VK_FORMAT_BC6H_UFLOAT_BLOCK,
    bc6h_sfloat_block = VK_FORMAT_BC6H_SFLOAT_BLOCK,
    bc7_unorm_block = VK_FORMAT_BC7_UNORM_BLOCK,
    bc7_srgb_block = VK_FORMAT_BC7_SRGB_BLOCK,
    etc2_r8g8b8_unorm_block = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    etc2_r8g8b8_srgb_block = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    etc2_r8g8b8a1_unorm_block = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    etc2_r8g8b8a1_srgb_block = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    etc2_r8g8b8a8_unorm_block = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    etc2_r8g8b8a8_srgb_block = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    eac_r11_unorm_block = VK_FORMAT_EAC_R11_UNORM_BLOCK,
    eac_r11_snorm_block = VK_FORMAT_EAC_R11_SNORM_BLOCK,
    eac_r11g11_unorm_block = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    eac_r11g11_snorm_block = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    astc_4x4_unorm_block = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    astc_4x4_srgb_block = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    astc_5x4_unorm_block = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    astc_5x4_srgb_block = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    astc_5x5_unorm_block = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    astc_5x5_srgb_block = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    astc_6x5_unorm_block = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    astc_6x5_srgb_block = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    astc_6x6_unorm_block = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    astc_6x6_srgb_block = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    astc_8x5_unorm_block = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    astc_8x5_srgb_block = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    astc_8x6_unorm_block = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    astc_8x6_srgb_block = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    astc_8x8_unorm_block = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    astc_8x8_srgb_block = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    astc_10x5_unorm_block = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    astc_10x5_srgb_block = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    astc_10x6_unorm_block = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    astc_10x6_srgb_block = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    astc_10x8_unorm_block = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    astc_10x8_srgb_block = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    astc_10x10_unorm_block = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    astc_10x10_srgb_block = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    astc_12x10_unorm_block = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    astc_12x10_srgb_block = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    astc_12x12_unorm_block = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    astc_12x12_srgb_block = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    g8b8g8_422_unorm = VK_FORMAT_G8B8G8R8_422_UNORM,
    b8g8r8_422_unorm = VK_FORMAT_B8G8R8G8_422_UNORM,
    g8_b8_r8_3plane_420_unorm = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    g8_b8r8_2plane_420_unorm = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    g8_b8_r8_3plane_422_unorm = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    g8_b8r8_2plane_422_unorm = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    g8_b8_r8_3plane_444_unorm = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    r10x6_unorm_pack16 = VK_FORMAT_R10X6_UNORM_PACK16,
    r10x6g_unorm_2pack1 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    r10x6g_unorm_4pack1 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    g10x6b_422_unorm_4pack1 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    b10x6g_422_unorm_4pack1 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    g10x6_b10x6_r10x6_3plane_420_unorm_3pack1 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    g10x6_b10x6r_2plane_420_unorm_3pack1 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    g10x6_b10x6_r10x6_3plane_422_unorm_3pack1 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    g10x6_b10x6r_2plane_422_unorm_3pack1 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    g10x6_b10x6_r10x6_3plane_444_unorm_3pack1 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    r12x4_unorm_pack16 = VK_FORMAT_R12X4_UNORM_PACK16,
    r12x4g_unorm_2pack1 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    r12x4g_unorm_4pack1 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    g12x4b_422_unorm_4pack1 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    b12x4g_422_unorm_4pack1 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    g12x4_b12x4_r12x4_3plane_420_unorm_3pack1 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    g12x4_b12x4r_2plane_420_unorm_3pack1 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    g12x4_b12x4_r12x4_3plane_422_unorm_3pack1 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    g12x4_b12x4r_2plane_422_unorm_3pack1 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    g12x4_b12x4_r12x4_3plane_444_unorm_3pack1 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    g16b16_422_unorm = VK_FORMAT_G16B16G16R16_422_UNORM,
    b16g16_422_unorm = VK_FORMAT_B16G16R16G16_422_UNORM,
    g16_b16_r16_3plane_420_unorm = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    g16_b16r16_2plane_420_unorm = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    g16_b16_r16_3plane_422_unorm = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    g16_b16r16_2plane_422_unorm = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    g16_b16_r16_3plane_444_unorm = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    g8_b8r8_2plane_444_unorm = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
    g10x6_b10x6r_2plane_444_unorm_3pack1 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
    g12x4_b12x4r_2plane_444_unorm_3pack1 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
    g16_b16r16_2plane_444_unorm = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
    a4r4g4b4_unorm_pack16 = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
    a4b4g4r4_unorm_pack16 = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
    astc_4x4_sfloat_block = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
    astc_5x4_sfloat_block = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
    astc_5x5_sfloat_block = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
    astc_6x5_sfloat_block = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
    astc_6x6_sfloat_block = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
    astc_8x5_sfloat_block = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
    astc_8x6_sfloat_block = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
    astc_8x8_sfloat_block = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
    astc_10x5_sfloat_block = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
    astc_10x6_sfloat_block = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
    astc_10x8_sfloat_block = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
    astc_10x10_sfloat_block = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
    astc_12x10_sfloat_block = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
    astc_12x12_sfloat_block = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
};

constexpr std::string format_str(Format val)
{
    using enum Format;

    switch(val) {
    case undfnd:
        return "undefined";
    case r4g4_unorm_pack8:
        return "r4g4 unorm pack8";
    case r4g4b4a4_unorm_pack16:
        return "r4g4b4a4 unorm pack16";
    case b4g4r4a4_unorm_pack16:
        return "b4g4r4a4 unorm pack16";
    case r5g6b5_unorm_pack16:
        return "r5g6b5 unorm pack16";
    case b5g6r5_unorm_pack16:
        return "b5g6r5 unorm pack16";
    case r5g5b5a1_unorm_pack16:
        return "r5g5b5a1 unorm pack16";
    case b5g5r5a1_unorm_pack16:
        return "b5g5r5a1 unorm pack16";
    case a1r5g5b5_unorm_pack16:
        return "a1r5g5b5 unorm pack16";
    case r8_unorm:
        return "r8 unorm";
    case r8_snorm:
        return "r8 snorm";
    case r8_uscld:
        return "r8 uscaled";
    case r8_sscld:
        return "r8 sscaled";
    case r8_uint:
        return "r8 uint";
    case r8_sint:
        return "r8 sint";
    case r8_srgb:
        return "r8 sRGB";
    case r8g8_unorm:
        return "r8g8 unorm";
    case r8g8_snorm:
        return "r8g8 snorm";
    case r8g8_uscld:
        return "r8g8 uscaled";
    case r8g8_sscld:
        return "r8g8 sscaled";
    case r8g8_uint:
        return "r8g8 uint";
    case r8g8_sint:
        return "r8g8 sint";
    case r8g8_srgb:
        return "r8g8 sRGB";
    case r8g8b8_unorm:
        return "r8g8b8 unorm";
    case r8g8b8_snorm:
        return "r8g8b8 snorm";
    case r8g8b8_uscld:
        return "r8g8b8 uscaled";
    case r8g8b8_sscld:
        return "r8g8b8 sscaled";
    case r8g8b8_uint:
        return "r8g8b8 uint";
    case r8g8b8_sint:
        return "r8g8b8 sint";
    case r8g8b8_srgb:
        return "r8g8b8 sRGB";
    case b8g8r8_unorm:
        return "b8g8r8 unorm";
    case b8g8r8_snorm:
        return "b8g8r8 snorm";
    case b8g8r8_uscld:
        return "b8g8r8 uscaled";
    case b8g8r8_sscld:
        return "b8g8r8 sscaled";
    case b8g8r8_uint:
        return "b8g8r8 uint";
    case b8g8r8_sint:
        return "b8g8r8 sint";
    case b8g8r8_srgb:
        return "b8g8r8 sRGB";
    case r8g8b8a8_unorm:
        return "r8g8b8a8 unorm";
    case r8g8b8a8_snorm:
        return "r8g8b8a8 snorm";
    case r8g8b8a8_uscld:
        return "r8g8b8a8 uscaled";
    case r8g8b8a8_sscld:
        return "r8g8b8a8 sscaled";
    case r8g8b8a8_uint:
        return "r8g8b8a8 uint";
    case r8g8b8a8_sint:
        return "r8g8b8a8 sint";
    case r8g8b8a8_srgb:
        return "r8g8b8a8 sRGB";
    case b8g8r8a8_unorm:
        return "b8g8r8a8 unorm";
    case b8g8r8a8_snorm:
        return "b8g8r8a8 snorm";
    case b8g8r8a8_uscld:
        return "b8g8r8a8 uscaled";
    case b8g8r8a8_sscld:
        return "b8g8r8a8 sscaled";
    case b8g8r8a8_uint:
        return "b8g8r8a8 uint";
    case b8g8r8a8_sint:
        return "b8g8r8a8 sint";
    case b8g8r8a8_srgb:
        return "b8g8r8a8 sRGB";
    case a8b8g8r8_unorm_pack32:
        return "a8b8g8r8 unorm pack32";
    case a8b8g8r8_snorm_pack32:
        return "a8b8g8r8 snorm pack32";
    case a8b8g8r8_uscld_pack32:
        return "a8b8g8r8 uscaled pack32";
    case a8b8g8r8_sscld_pack32:
        return "a8b8g8r8 sscaled pack32";
    case a8b8g8r8_uint_pack32:
        return "a8b8g8r8 uint pack32";
    case a8b8g8r8_sint_pack32:
        return "a8b8g8r8 sint pack32";
    case a8b8g8r8_srgb_pack32:
        return "a8b8g8r8 sRGB pack32";
    case a2r10g10b10_unorm_pack32:
        return "a2r10g10b10 unorm pack32";
    case a2r10g10b10_snorm_pack32:
        return "a2r10g10b10 snorm pack32";
    case a2r10g10b10_uscld_pack32:
        return "a2r10g10b10 uscaled pack32";
    case a2r10g10b10_sscld_pack32:
        return "a2r10g10b10 sscaled pack32";
    case a2r10g10b10_uint_pack32:
        return "a2r10g10b10 uint pack32";
    case a2r10g10b10_sint_pack32:
        return "a2r10g10b10 sint pack32";
    case a2b10g10r10_unorm_pack32:
        return "a2b10g10r10 unorm pack32";
    case a2b10g10r10_snorm_pack32:
        return "a2b10g10r10 snorm pack32";
    case a2b10g10r10_uscld_pack32:
        return "a2b10g10r10 uscaled pack32";
    case a2b10g10r10_sscld_pack32:
        return "a2b10g10r10 sscaled pack32";
    case a2b10g10r10_uint_pack32:
        return "a2b10g10r10 uint pack32";
    case a2b10g10r10_sint_pack32:
        return "a2b10g10r10 sint pack32";
    case r16_unorm:
        return "r16 unorm";
    case r16_snorm:
        return "r16 snorm";
    case r16_uscld:
        return "r16 uscaled";
    case r16_sscld:
        return "r16 sscaled";
    case r16_uint:
        return "r16 uint";
    case r16_sint:
        return "r16 sint";
    case r16_sfloat:
        return "r16 sfloat";
    case r16g16_unorm:
        return "r16g16 unorm";
    case r16g16_snorm:
        return "r16g16 snorm";
    case r16g16_uscld:
        return "r16g16 uscaled";
    case r16g16_sscld:
        return "r16g16 sscaled";
    case r16g16_uint:
        return "r16g16 uint";
    case r16g16_sint:
        return "r16g16 sint";
    case r16g16_sfloat:
        return "r16g16 sfloat";
    case r16g16b16_unorm:
        return "r16g16b16 unorm";
    case r16g16b16_snorm:
        return "r16g16b16 snorm";
    case r16g16b16_uscld:
        return "r16g16b16 uscaled";
    case r16g16b16_sscld:
        return "r16g16b16 sscaled";
    case r16g16b16_uint:
        return "r16g16b16 uint";
    case r16g16b16_sint:
        return "r16g16b16 sint";
    case r16g16b16_sfloat:
        return "r16g16b16 sfloat";
    case r16g16b16a16_unorm:
        return "r16g16b16a16 unorm";
    case r16g16b16a16_snorm:
        return "r16g16b16a16 snorm";
    case r16g16b16a16_uscld:
        return "r16g16b16a16 uscaled";
    case r16g16b16a16_sscld:
        return "r16g16b16a16 sscaled";
    case r16g16b16a16_uint:
        return "r16g16b16a16 uint";
    case r16g16b16a16_sint:
        return "r16g16b16a16 sint";
    case r16g16b16a16_sfloat:
        return "r16g16b16a16 sfloat";
    case r32_uint:
        return "r32 uint";
    case r32_sint:
        return "r32 sint";
    case r32_sfloat:
        return "r32 sfloat";
    case r32g32_uint:
        return "r32g32 uint";
    case r32g32_sint:
        return "r32g32 sint";
    case r32g32_sfloat:
        return "r32g32 sfloat";
    case r32g32b32_uint:
        return "r32g32b32 uint";
    case r32g32b32_sint:
        return "r32g32b32 sint";
    case r32g32b32_sfloat:
        return "r32g32b32 sfloat";
    case r32g32b32a32_uint:
        return "r32g32b32a32 uint";
    case r32g32b32a32_sint:
        return "r32g32b32a32 sint";
    case r32g32b32a32_sfloat:
        return "r32g32b32a32 sfloat";
    case r64_uint:
        return "r64 uint";
    case r64_sint:
        return "r64 sint";
    case r64_sfloat:
        return "r64 sfloat";
    case r64g64_uint:
        return "r64g64 uint";
    case r64g64_sint:
        return "r64g64 sint";
    case r64g64_sfloat:
        return "r64g64 sfloat";
    case r64g64b64_uint:
        return "r64g64b64 uint";
    case r64g64b64_sint:
        return "r64g64b64 sint";
    case r64g64b64_sfloat:
        return "r64g64b64 sfloat";
    case r64g64b64a64_uint:
        return "r64g64b64a64 uint";
    case r64g64b64a64_sint:
        return "r64g64b64a64 sint";
    case r64g64b64a64_sfloat:
        return "r64g64b64a64 sfloat";
    case b10g11_ufloat_pack32:
        return "b10g11r11 ufloat pack32";
    case e5b9g9_ufloat_pack32:
        return "e5b9g9r9 ufloat pack32";
    case d16_unorm:
        return "d16 unorm";
    case x8_d24_unorm_pack32:
        return "x8 d24 unorm pack32";
    case d32_sfloat:
        return "d32 sfloat";
    case s8_uint:
        return "s8 uint";
    case d16_unorm_s8_uint:
        return "d16 unorm s8 uint";
    case d24_unorm_s8_uint:
        return "d24 unorm s8 uint";
    case d32_sfloat_s8_uint:
        return "d32 sfloat s8 uint";
    case bc1_rgb_unorm_block:
        return "bc1 rgb unorm block";
    case bc1_rgb_srgb_block:
        return "bc1 rgb sRGB block";
    case bc1_rgba_unorm_block:
        return "bc1 rgba unorm block";
    case bc1_rgba_srgb_block:
        return "bc1 rgba sRGB block";
    case bc2_unorm_block:
        return "bc2 unorm block";
    case bc2_srgb_block:
        return "bc2 sRGB block";
    case bc3_unorm_block:
        return "bc3 unorm block";
    case bc3_srgb_block:
        return "bc3 sRGB block";
    case bc4_unorm_block:
        return "bc4 unorm block";
    case bc4_snorm_block:
        return "bc4 snorm block";
    case bc5_unorm_block:
        return "bc5 unorm block";
    case bc5_snorm_block:
        return "bc5 snorm block";
    case bc6h_ufloat_block:
        return "bc6h ufloat block";
    case bc6h_sfloat_block:
        return "bc6h sfloat block";
    case bc7_unorm_block:
        return "bc7 unorm block";
    case bc7_srgb_block:
        return "bc7 sRGB block";
    case etc2_r8g8b8_unorm_block:
        return "etc2 r8g8b8 unorm block";
    case etc2_r8g8b8_srgb_block:
        return "etc2 r8g8b8 sRGB block";
    case etc2_r8g8b8a1_unorm_block:
        return "etc2 r8g8b8a1 unorm block";
    case etc2_r8g8b8a1_srgb_block:
        return "etc2 r8g8b8a1 sRGB block";
    case etc2_r8g8b8a8_unorm_block:
        return "etc2 r8g8b8a8 unorm block";
    case etc2_r8g8b8a8_srgb_block:
        return "etc2 r8g8b8a8 sRGB block";
    case eac_r11_unorm_block:
        return "eac r11 unorm block";
    case eac_r11_snorm_block:
        return "eac r11 snorm block";
    case eac_r11g11_unorm_block:
        return "eac r11g11 unorm block";
    case eac_r11g11_snorm_block:
        return "eac r11g11 snorm block";
    case astc_4x4_unorm_block:
        return "astc 4x4 unorm block";
    case astc_4x4_srgb_block:
        return "astc 4x4 sRGB block";
    case astc_5x4_unorm_block:
        return "astc 5x4 unorm block";
    case astc_5x4_srgb_block:
        return "astc 5x4 sRGB block";
    case astc_5x5_unorm_block:
        return "astc 5x5 unorm block";
    case astc_5x5_srgb_block:
        return "astc 5x5 sRGB block";
    case astc_6x5_unorm_block:
        return "astc 6x5 unorm block";
    case astc_6x5_srgb_block:
        return "astc 6x5 sRGB block";
    case astc_6x6_unorm_block:
        return "astc 6x6 unorm block";
    case astc_6x6_srgb_block:
        return "astc 6x6 sRGB block";
    case astc_8x5_unorm_block:
        return "astc 8x5 unorm block";
    case astc_8x5_srgb_block:
        return "astc 8x5 sRGB block";
    case astc_8x6_unorm_block:
        return "astc 8x6 unorm block";
    case astc_8x6_srgb_block:
        return "astc 8x6 sRGB block";
    case astc_8x8_unorm_block:
        return "astc 8x8 unorm block";
    case astc_8x8_srgb_block:
        return "astc 8x8 sRGB block";
    case astc_10x5_unorm_block:
        return "astc 10x5 unorm block";
    case astc_10x5_srgb_block:
        return "astc 10x5 sRGB block";
    case astc_10x6_unorm_block:
        return "astc 10x6 unorm block";
    case astc_10x6_srgb_block:
        return "astc 10x6 sRGB block";
    case astc_10x8_unorm_block:
        return "astc 10x8 unorm block";
    case astc_10x8_srgb_block:
        return "astc 10x8 sRGB block";
    case astc_10x10_unorm_block:
        return "astc 10x10 unorm block";
    case astc_10x10_srgb_block:
        return "astc 10x10 sRGB block";
    case astc_12x10_unorm_block:
        return "astc 12x10 unorm block";
    case astc_12x10_srgb_block:
        return "astc 12x10 sRGB block";
    case astc_12x12_unorm_block:
        return "astc 12x12 unorm block";
    case astc_12x12_srgb_block:
        return "astc 12x12 sRGB block";
    case g8b8g8_422_unorm:
        return "g8b8g8r8 422 unorm";
    case b8g8r8_422_unorm:
        return "b8g8r8g8 422 unorm";
    case g8_b8_r8_3plane_420_unorm:
        return "g8 b8 r8 3plane 420 unorm";
    case g8_b8r8_2plane_420_unorm:
        return "g8 b8r8 2plane 420 unorm";
    case g8_b8_r8_3plane_422_unorm:
        return "g8 b8 r8 3plane 422 unorm";
    case g8_b8r8_2plane_422_unorm:
        return "g8 b8r8 2plane 422 unorm";
    case g8_b8_r8_3plane_444_unorm:
        return "g8 b8 r8 3plane 444 unorm";
    case r10x6_unorm_pack16:
        return "r10x6 unorm pack16";
    case r10x6g_unorm_2pack1:
        return "r10x6g10x6 unorm 2pack16";
    case r10x6g_unorm_4pack1:
        return "r10x6g10x6b10x6a10x6 unorm 4pack16";
    case g10x6b_422_unorm_4pack1:
        return "g10x6b10x6g10x6r10x6 422 unorm 4pack16";
    case b10x6g_422_unorm_4pack1:
        return "b10x6g10x6r10x6g10x6 422 unorm 4pack16";
    case g10x6_b10x6_r10x6_3plane_420_unorm_3pack1:
        return "g10x6 b10x6 r10x6 3plane 420 unorm 3pack16";
    case g10x6_b10x6r_2plane_420_unorm_3pack1:
        return "g10x6 b10x6r10x6 2plane 420 unorm 3pack16";
    case g10x6_b10x6_r10x6_3plane_422_unorm_3pack1:
        return "g10x6 b10x6 r10x6 3plane 422 unorm 3pack16";
    case g10x6_b10x6r_2plane_422_unorm_3pack1:
        return "g10x6 b10x6r10x6 2plane 422 unorm 3pack16";
    case g10x6_b10x6_r10x6_3plane_444_unorm_3pack1:
        return "g10x6 b10x6 r10x6 3plane 444 unorm 3pack16";
    case r12x4_unorm_pack16:
        return "r12x4 unorm pack16";
    case r12x4g_unorm_2pack1:
        return "r12x4g12x4 unorm 2pack16";
    case r12x4g_unorm_4pack1:
        return "r12x4g12x4b12x4a12x4 unorm 4pack16";
    case g12x4b_422_unorm_4pack1:
        return "g12x4b12x4g12x4r12x4 422 unorm 4pack16";
    case b12x4g_422_unorm_4pack1:
        return "b12x4g12x4r12x4g12x4 422 unorm 4pack16";
    case g12x4_b12x4_r12x4_3plane_420_unorm_3pack1:
        return "g12x4 b12x4 r12x4 3plane 420 unorm 3pack16";
    case g12x4_b12x4r_2plane_420_unorm_3pack1:
        return "g12x4 b12x4r12x4 2plane 420 unorm 3pack16";
    case g12x4_b12x4_r12x4_3plane_422_unorm_3pack1:
        return "g12x4 b12x4 r12x4 3plane 422 unorm 3pack16";
    case g12x4_b12x4r_2plane_422_unorm_3pack1:
        return "g12x4 b12x4r12x4 2plane 422 unorm 3pack16";
    case g12x4_b12x4_r12x4_3plane_444_unorm_3pack1:
        return "g12x4 b12x4 r12x4 3plane 444 unorm 3pack16";
    case g16b16_422_unorm:
        return "g16b16g16r16 422 unorm";
    case b16g16_422_unorm:
        return "b16g16r16g16 422 unorm";
    case g16_b16_r16_3plane_420_unorm:
        return "g16 b16 r16 3plane 420 unorm";
    case g16_b16r16_2plane_420_unorm:
        return "g16 b16r16 2plane 420 unorm";
    case g16_b16_r16_3plane_422_unorm:
        return "g16 b16 r16 3plane 422 unorm";
    case g16_b16r16_2plane_422_unorm:
        return "g16 b16r16 2plane 422 unorm";
    case g16_b16_r16_3plane_444_unorm:
        return "g16 b16 r16 3plane 444 unorm";
    case g8_b8r8_2plane_444_unorm:
        return "g8 b8r8 2plane 444 unorm";
    case g10x6_b10x6r_2plane_444_unorm_3pack1:
        return "g10x6 b10x6r10x6 2plane 444 unorm 3pack16";
    case g12x4_b12x4r_2plane_444_unorm_3pack1:
        return "g12x4 b12x4r12x4 2plane 444 unorm 3pack16";
    case g16_b16r16_2plane_444_unorm:
        return "g16 b16r16 2plane 444 unorm";
    case a4r4g4b4_unorm_pack16:
        return "a4r4g4b4 unorm pack16";
    case a4b4g4r4_unorm_pack16:
        return "a4b4g4r4 unorm pack16";
    case astc_4x4_sfloat_block:
        return "astc 4x4 sfloat block";
    case astc_5x4_sfloat_block:
        return "astc 5x4 sfloat block";
    case astc_5x5_sfloat_block:
        return "astc 5x5 sfloat block";
    case astc_6x5_sfloat_block:
        return "astc 6x5 sfloat block";
    case astc_6x6_sfloat_block:
        return "astc 6x6 sfloat block";
    case astc_8x5_sfloat_block:
        return "astc 8x5 sfloat block";
    case astc_8x6_sfloat_block:
        return "astc 8x6 sfloat block";
    case astc_8x8_sfloat_block:
        return "astc 8x8 sfloat block";
    case astc_10x5_sfloat_block:
        return "astc 10x5 sfloat block";
    case astc_10x6_sfloat_block:
        return "astc 10x6 sfloat block";
    case astc_10x8_sfloat_block:
        return "astc 10x8 sfloat block";
    case astc_10x10_sfloat_block:
        return "astc 10x10 sfloat block";
    case astc_12x10_sfloat_block:
        return "astc 12x10 sfloat block";
    case astc_12x12_sfloat_block:
        return "astc 12x12 sfloat block";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string format_str(VkFormat val)
{
    return format_str(static_cast<Format>(val));
}

/*!
 * \brief Maps to VkStructureType. Should be safe to static_cast between.
 */
enum class StructureType {
    applctn_info = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    instnc_create_info = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    device_queue_create_info = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    device_create_info = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    submit_info = VK_STRUCTURE_TYPE_SUBMIT_INFO,
    memory_allcte_info = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    mapped_memory_range = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    bind_sparse_info = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    fence_create_info = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    smphre_create_info = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    event_create_info = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    query_pool_create_info = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    buffer_create_info = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    buffer_view_create_info = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    img_create_info = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    img_view_create_info = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    shader_module_create_info = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    pplne_cache_create_info = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    pplne_shader_stage_create_info = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    pplne_vertex_input_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    pplne_input_assmbly_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    pplne_tsslltn_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    pplne_vwprt_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    pplne_rstrztn_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    pplne_mltsmpl_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    pplne_depth_stncl_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    pplne_color_blend_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    pplne_dynmc_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    grphcs_pplne_create_info = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    cmpte_pplne_create_info = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    pplne_layout_create_info = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    smplr_create_info = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    dscrpt_set_layout_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    dscrpt_pool_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    dscrpt_set_allcte_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    write_dscrpt_set = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    copy_dscrpt_set = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    frmbff_create_info = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    render_pass_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    cmmnd_pool_create_info = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    cmmnd_buffer_allcte_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    cmmnd_buffer_inhrtn_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    cmmnd_buffer_begin_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    render_pass_begin_info = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    buffer_memory_brrr = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    img_memory_brrr = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    memory_brrr = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    loader_instnc_create_info = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO,
    loader_device_create_info = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    physcl_device_sbgrp_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    bind_buffer_memory_info = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    bind_img_memory_info = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    physcl_device_16bit_strge_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    memory_ddctd_rqrmnts = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    memory_ddctd_allcte_info = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    memory_allcte_flags_info = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    device_group_render_pass_begin_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    device_group_cmmnd_buffer_begin_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    device_group_submit_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    device_group_bind_sparse_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    bind_buffer_memory_device_group_info = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    bind_img_memory_device_group_info = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    physcl_device_group_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    device_group_device_create_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    buffer_memory_rqrmnts_info_2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    img_memory_rqrmnts_info_2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    img_sparse_memory_rqrmnts_info_2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    memory_rqrmnts_2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    sparse_img_memory_rqrmnts_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    physcl_device_ftrs_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    physcl_device_prprts_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    format_prprts_2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    img_format_prprts_2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    physcl_device_img_format_info_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    queue_family_prprts_2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    physcl_device_memory_prprts_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    sparse_img_format_prprts_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    physcl_device_sparse_img_format_info_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    physcl_device_point_clppng_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    render_pass_input_attchmt_aspect_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    img_view_usage_create_info = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    pplne_tsslltn_domain_origin_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    render_pass_mltvw_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    physcl_device_mltvw_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    physcl_device_mltvw_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    physcl_device_vrble_pntrs_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    prtctd_submit_info = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    physcl_device_prtctd_memory_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    physcl_device_prtctd_memory_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    device_queue_info_2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    smplr_ycbcr_cnvrsn_create_info = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    smplr_ycbcr_cnvrsn_info = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    bind_img_plane_memory_info = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    img_plane_memory_rqrmnts_info = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    physcl_device_smplr_ycbcr_cnvrsn_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    smplr_ycbcr_cnvrsn_img_format_prprts = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    dscrpt_update_tmplte_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    physcl_device_extrnl_img_format_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    extrnl_img_format_prprts = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    physcl_device_extrnl_buffer_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    extrnl_buffer_prprts = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    physcl_device_id_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    extrnl_memory_buffer_create_info = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    extrnl_memory_img_create_info = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    export_memory_allcte_info = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    physcl_device_extrnl_fence_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    extrnl_fence_prprts = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    export_fence_create_info = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    export_smphre_create_info = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    physcl_device_extrnl_smphre_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    extrnl_smphre_prprts = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    physcl_device_mntnnc_3_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    dscrpt_set_layout_spprt = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    physcl_device_shader_draw_prmtrs_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    physcl_device_vulkan_1_1_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
    physcl_device_vulkan_1_1_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
    physcl_device_vulkan_1_2_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
    physcl_device_vulkan_1_2_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
    img_format_list_create_info = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
    attchmt_dscrptn_2 = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
    attchmt_rfrnce_2 = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
    sbpss_dscrptn_2 = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
    sbpss_dpndncy_2 = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
    render_pass_create_info_2 = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
    sbpss_begin_info = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
    sbpss_end_info = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
    physcl_device_8bit_strge_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
    physcl_device_driver_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
    physcl_device_shader_atomic_int64_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
    physcl_device_shader_float16_int8_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
    physcl_device_float_cntrls_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
    dscrpt_set_layout_bndng_flags_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
    physcl_device_dscrpt_indxng_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
    physcl_device_dscrpt_indxng_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
    dscrpt_set_vrble_dscrpt_count_allcte_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
    dscrpt_set_vrble_dscrpt_count_layout_spprt = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
    physcl_device_depth_stncl_rslve_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
    sbpss_dscrptn_depth_stncl_rslve = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
    physcl_device_scalar_block_layout_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
    img_stncl_usage_create_info = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
    physcl_device_smplr_filter_minmax_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
    smplr_rdctn_mode_create_info = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
    physcl_device_vulkan_memory_model_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
    physcl_device_imglss_frmbff_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
    frmbff_attchms_create_info = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
    frmbff_attchmt_img_info = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
    render_pass_attchmt_begin_info = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
    physcl_device_unfrm_buffer_stndrd_layout_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
    physcl_device_shader_sbgrp_extndd_types_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
    physcl_device_sprte_depth_stncl_lyts_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
    attchmt_rfrnce_stncl_layout = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
    attchmt_dscrptn_stncl_layout = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
    physcl_device_host_query_reset_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
    physcl_device_tmlne_smphre_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
    physcl_device_tmlne_smphre_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
    smphre_type_create_info = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
    tmlne_smphre_submit_info = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
    smphre_wait_info = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
    smphre_signal_info = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
    physcl_device_buffer_device_addrss_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
    buffer_device_addrss_info = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
    buffer_opaque_cptre_addrss_create_info = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
    memory_opaque_cptre_addrss_allcte_info = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
    device_memory_opaque_cptre_addrss_info = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
    physcl_device_vulkan_1_3_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
    physcl_device_vulkan_1_3_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
    pplne_crtn_fdbck_create_info = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
    physcl_device_shader_trmnte_invctn_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
    physcl_device_tool_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
    physcl_device_shader_demote_to_helper_invctn_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
    physcl_device_prvte_data_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
    device_prvte_data_create_info = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
    prvte_data_slot_create_info = VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
    physcl_device_pplne_crtn_cache_cntrl_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
    memory_brrr_2 = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
    buffer_memory_brrr_2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
    img_memory_brrr_2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
    dpndncy_info = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
    submit_info_2 = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
    smphre_submit_info = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
    cmmnd_buffer_submit_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
    physcl_device_synchrn_2_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
    physcl_device_zero_intlze_wrkgrp_memory_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
    physcl_device_img_rbstns_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
    copy_buffer_info_2 = VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
    copy_img_info_2 = VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
    copy_buffer_to_img_info_2 = VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
    copy_img_to_buffer_info_2 = VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
    blit_img_info_2 = VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
    rslve_img_info_2 = VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
    buffer_copy_2 = VK_STRUCTURE_TYPE_BUFFER_COPY_2,
    img_copy_2 = VK_STRUCTURE_TYPE_IMAGE_COPY_2,
    img_blit_2 = VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
    buffer_img_copy_2 = VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
    img_rslve_2 = VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
    physcl_device_sbgrp_size_cntrl_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
    pplne_shader_stage_rqrd_sbgrp_size_create_info = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
    physcl_device_sbgrp_size_cntrl_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
    physcl_device_inline_unfrm_block_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
    physcl_device_inline_unfrm_block_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
    write_dscrpt_set_inline_unfrm_block = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
    dscrpt_pool_inline_unfrm_block_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
    physcl_device_txtre_cmprssn_astc_hdr_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
    rndrng_info = VK_STRUCTURE_TYPE_RENDERING_INFO,
    rndrng_attchmt_info = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
    pplne_rndrng_create_info = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
    physcl_device_dynmc_rndrng_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
    cmmnd_buffer_inhrtn_rndrng_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
    physcl_device_shader_intgr_dot_prdct_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
    physcl_device_shader_intgr_dot_prdct_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
    physcl_device_texel_buffer_algnmnt_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
    format_prprts_3 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
    physcl_device_mntnnc_4_ftrs = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
    physcl_device_mntnnc_4_prprts = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
    device_buffer_memory_rqrmnts = VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
    device_img_memory_rqrmnts = VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
};

constexpr std::string strctr_type_str(StructureType val)
{
    using enum StructureType;

    switch(val) {
    case applctn_info:
        return "application info";
    case instnc_create_info:
        return "instance create info";
    case device_queue_create_info:
        return "device queue create info";
    case device_create_info:
        return "device create info";
    case submit_info:
        return "submit info";
    case memory_allcte_info:
        return "memory allocate info";
    case mapped_memory_range:
        return "mapped memory range";
    case bind_sparse_info:
        return "bind sparse info";
    case fence_create_info:
        return "fence create info";
    case smphre_create_info:
        return "semaphore create info";
    case event_create_info:
        return "event create info";
    case query_pool_create_info:
        return "query pool create info";
    case buffer_create_info:
        return "buffer create info";
    case buffer_view_create_info:
        return "buffer view create info";
    case img_create_info:
        return "image create info";
    case img_view_create_info:
        return "image view create info";
    case shader_module_create_info:
        return "shader module create info";
    case pplne_cache_create_info:
        return "pipeline cache create info";
    case pplne_shader_stage_create_info:
        return "pipeline shader stage create info";
    case pplne_vertex_input_state_create_info:
        return "pipeline vertex input state create info";
    case pplne_input_assmbly_state_create_info:
        return "pipeline input assembly state create info";
    case pplne_tsslltn_state_create_info:
        return "pipeline tessellation state create info";
    case pplne_vwprt_state_create_info:
        return "pipeline viewport state create info";
    case pplne_rstrztn_state_create_info:
        return "pipeline rasterization state create info";
    case pplne_mltsmpl_state_create_info:
        return "pipeline multisample state create info";
    case pplne_depth_stncl_state_create_info:
        return "pipeline depth/stencil state create info";
    case pplne_color_blend_state_create_info:
        return "pipeline color blend state create info";
    case pplne_dynmc_state_create_info:
        return "pipeline dynamic state create info";
    case grphcs_pplne_create_info:
        return "graphics pipeline create info";
    case cmpte_pplne_create_info:
        return "compute pipeline create info";
    case pplne_layout_create_info:
        return "pipeline layout create info";
    case smplr_create_info:
        return "sampler create info";
    case dscrpt_set_layout_create_info:
        return "descriptor set layout create info";
    case dscrpt_pool_create_info:
        return "descriptor pool create info";
    case dscrpt_set_allcte_info:
        return "descriptor set allocate info";
    case write_dscrpt_set:
        return "write descriptor set";
    case copy_dscrpt_set:
        return "copy descriptor set";
    case frmbff_create_info:
        return "framebuffer create info";
    case render_pass_create_info:
        return "render pass create info";
    case cmmnd_pool_create_info:
        return "command pool create info";
    case cmmnd_buffer_allcte_info:
        return "command buffer allocate info";
    case cmmnd_buffer_inhrtn_info:
        return "command buffer inheritance info";
    case cmmnd_buffer_begin_info:
        return "command buffer begin info";
    case render_pass_begin_info:
        return "render pass begin info";
    case buffer_memory_brrr:
        return "buffer memory barrier";
    case img_memory_brrr:
        return "image memory barrier";
    case memory_brrr:
        return "memory barrier";
    case loader_instnc_create_info:
        return "loader instance create info";
    case loader_device_create_info:
        return "loader device create info";
    case physcl_device_sbgrp_prprts:
        return "physical device subgroup properties";
    case bind_buffer_memory_info:
        return "bind buffer memory info";
    case bind_img_memory_info:
        return "bind image memory info";
    case physcl_device_16bit_strge_ftrs:
        return "physical device 16bit storage features";
    case memory_ddctd_rqrmnts:
        return "memory dedicated requirements";
    case memory_ddctd_allcte_info:
        return "memory dedicated allocate info";
    case memory_allcte_flags_info:
        return "memory allocate flags info";
    case device_group_render_pass_begin_info:
        return "device group render pass begin info";
    case device_group_cmmnd_buffer_begin_info:
        return "device group command buffer begin info";
    case device_group_submit_info:
        return "device group submit info";
    case device_group_bind_sparse_info:
        return "device group bind sparse info";
    case bind_buffer_memory_device_group_info:
        return "bind buffer memory device group info";
    case bind_img_memory_device_group_info:
        return "bind image memory device group info";
    case physcl_device_group_prprts:
        return "physical device group properties";
    case device_group_device_create_info:
        return "device group device create info";
    case buffer_memory_rqrmnts_info_2:
        return "buffer memory requirements info 2";
    case img_memory_rqrmnts_info_2:
        return "image memory requirements info 2";
    case img_sparse_memory_rqrmnts_info_2:
        return "image sparse memory requirements info 2";
    case memory_rqrmnts_2:
        return "memory requirements 2";
    case sparse_img_memory_rqrmnts_2:
        return "sparse image memory requirements 2";
    case physcl_device_ftrs_2:
        return "physical device features 2";
    case physcl_device_prprts_2:
        return "physical device properties 2";
    case format_prprts_2:
        return "format properties 2";
    case img_format_prprts_2:
        return "image format properties 2";
    case physcl_device_img_format_info_2:
        return "physical device image format info 2";
    case queue_family_prprts_2:
        return "queue family properties 2";
    case physcl_device_memory_prprts_2:
        return "physical device memory properties 2";
    case sparse_img_format_prprts_2:
        return "sparse image format properties 2";
    case physcl_device_sparse_img_format_info_2:
        return "physical device sparse image format info 2";
    case physcl_device_point_clppng_prprts:
        return "physical device point clipping properties";
    case render_pass_input_attchmt_aspect_create_info:
        return "render pass input attachment aspect create info";
    case img_view_usage_create_info:
        return "image view usage create info";
    case pplne_tsslltn_domain_origin_state_create_info:
        return "pipeline tessellation domain origin state create info";
    case render_pass_mltvw_create_info:
        return "render pass multiview create info";
    case physcl_device_mltvw_ftrs:
        return "physical device multiview features";
    case physcl_device_mltvw_prprts:
        return "physical device multiview properties";
    case physcl_device_vrble_pntrs_ftrs:
        return "physical device variable pointers features";
    case prtctd_submit_info:
        return "protected submit info";
    case physcl_device_prtctd_memory_ftrs:
        return "physical device protected memory features";
    case physcl_device_prtctd_memory_prprts:
        return "physical device protected memory properties";
    case device_queue_info_2:
        return "device queue info 2";
    case smplr_ycbcr_cnvrsn_create_info:
        return "sampler ycbcr conversion create info";
    case smplr_ycbcr_cnvrsn_info:
        return "sampler ycbcr conversion info";
    case bind_img_plane_memory_info:
        return "bind image plane memory info";
    case img_plane_memory_rqrmnts_info:
        return "image plane memory requirements info";
    case physcl_device_smplr_ycbcr_cnvrsn_ftrs:
        return "physical device sampler ycbcr conversion features";
    case smplr_ycbcr_cnvrsn_img_format_prprts:
        return "sampler ycbcr conversion image format properties";
    case dscrpt_update_tmplte_create_info:
        return "descriptor update template create info";
    case physcl_device_extrnl_img_format_info:
        return "physical device external image format info";
    case extrnl_img_format_prprts:
        return "external image format properties";
    case physcl_device_extrnl_buffer_info:
        return "physical device external buffer info";
    case extrnl_buffer_prprts:
        return "external buffer properties";
    case physcl_device_id_prprts:
        return "physical device id properties";
    case extrnl_memory_buffer_create_info:
        return "external memory buffer create info";
    case extrnl_memory_img_create_info:
        return "external memory image create info";
    case export_memory_allcte_info:
        return "export memory allocate info";
    case physcl_device_extrnl_fence_info:
        return "physical device external fence info";
    case extrnl_fence_prprts:
        return "external fence properties";
    case export_fence_create_info:
        return "export fence create info";
    case export_smphre_create_info:
        return "export semaphore create info";
    case physcl_device_extrnl_smphre_info:
        return "physical device external semaphore info";
    case extrnl_smphre_prprts:
        return "external semaphore properties";
    case physcl_device_mntnnc_3_prprts:
        return "physical device maintenance 3 properties";
    case dscrpt_set_layout_spprt:
        return "descriptor set layout support";
    case physcl_device_shader_draw_prmtrs_ftrs:
        return "physical device shader draw parameters features";
    case physcl_device_vulkan_1_1_ftrs:
        return "physical device vulkan 1 1 features";
    case physcl_device_vulkan_1_1_prprts:
        return "physical device vulkan 1 1 properties";
    case physcl_device_vulkan_1_2_ftrs:
        return "physical device vulkan 1 2 features";
    case physcl_device_vulkan_1_2_prprts:
        return "physical device vulkan 1 2 properties";
    case img_format_list_create_info:
        return "image format list create info";
    case attchmt_dscrptn_2:
        return "attachment description 2";
    case attchmt_rfrnce_2:
        return "attachment reference 2";
    case sbpss_dscrptn_2:
        return "subpass description 2";
    case sbpss_dpndncy_2:
        return "subpass dependency 2";
    case render_pass_create_info_2:
        return "render pass create info 2";
    case sbpss_begin_info:
        return "subpass begin info";
    case sbpss_end_info:
        return "subpass end info";
    case physcl_device_8bit_strge_ftrs:
        return "physical device 8bit storage features";
    case physcl_device_driver_prprts:
        return "physical device driver properties";
    case physcl_device_shader_atomic_int64_ftrs:
        return "physical device shader atomic int64 features";
    case physcl_device_shader_float16_int8_ftrs:
        return "physical device shader float16 int8 features";
    case physcl_device_float_cntrls_prprts:
        return "physical device float controls properties";
    case dscrpt_set_layout_bndng_flags_create_info:
        return "descriptor set layout binding flags create info";
    case physcl_device_dscrpt_indxng_ftrs:
        return "physical device descriptor indexing features";
    case physcl_device_dscrpt_indxng_prprts:
        return "physical device descriptor indexing properties";
    case dscrpt_set_vrble_dscrpt_count_allcte_info:
        return "descriptor set variable descriptor count allocate info";
    case dscrpt_set_vrble_dscrpt_count_layout_spprt:
        return "descriptor set variable descriptor count layout support";
    case physcl_device_depth_stncl_rslve_prprts:
        return "physical device depth/stencil resolve properties";
    case sbpss_dscrptn_depth_stncl_rslve:
        return "subpass description depth/stencil resolve";
    case physcl_device_scalar_block_layout_ftrs:
        return "physical device scalar block layout features";
    case img_stncl_usage_create_info:
        return "image stencil usage create info";
    case physcl_device_smplr_filter_minmax_prprts:
        return "physical device sampler filter minmax properties";
    case smplr_rdctn_mode_create_info:
        return "sampler reduction mode create info";
    case physcl_device_vulkan_memory_model_ftrs:
        return "physical device vulkan memory model features";
    case physcl_device_imglss_frmbff_ftrs:
        return "physical device imageless framebuffer features";
    case frmbff_attchms_create_info:
        return "framebuffer attachments create info";
    case frmbff_attchmt_img_info:
        return "framebuffer attachment image info";
    case render_pass_attchmt_begin_info:
        return "render pass attachment begin info";
    case physcl_device_unfrm_buffer_stndrd_layout_ftrs:
        return "physical device uniform buffer standard layout features";
    case physcl_device_shader_sbgrp_extndd_types_ftrs:
        return "physical device shader subgroup extended types features";
    case physcl_device_sprte_depth_stncl_lyts_ftrs:
        return "physical device separate depth/stencil layouts features";
    case attchmt_rfrnce_stncl_layout:
        return "attachment reference stencil layout";
    case attchmt_dscrptn_stncl_layout:
        return "attachment description stencil layout";
    case physcl_device_host_query_reset_ftrs:
        return "physical device host query reset features";
    case physcl_device_tmlne_smphre_ftrs:
        return "physical device timeline semaphore features";
    case physcl_device_tmlne_smphre_prprts:
        return "physical device timeline semaphore properties";
    case smphre_type_create_info:
        return "semaphore type create info";
    case tmlne_smphre_submit_info:
        return "timeline semaphore submit info";
    case smphre_wait_info:
        return "semaphore wait info";
    case smphre_signal_info:
        return "semaphore signal info";
    case physcl_device_buffer_device_addrss_ftrs:
        return "physical device buffer device address features";
    case buffer_device_addrss_info:
        return "buffer device address info";
    case buffer_opaque_cptre_addrss_create_info:
        return "buffer opaque capture address create info";
    case memory_opaque_cptre_addrss_allcte_info:
        return "memory opaque capture address allocate info";
    case device_memory_opaque_cptre_addrss_info:
        return "device memory opaque capture address info";
    case physcl_device_vulkan_1_3_ftrs:
        return "physical device vulkan 1 3 features";
    case physcl_device_vulkan_1_3_prprts:
        return "physical device vulkan 1 3 properties";
    case pplne_crtn_fdbck_create_info:
        return "pipeline creation feedback create info";
    case physcl_device_shader_trmnte_invctn_ftrs:
        return "physical device shader terminate invocation features";
    case physcl_device_tool_prprts:
        return "physical device tool properties";
    case physcl_device_shader_demote_to_helper_invctn_ftrs:
        return "physical device shader demote to helper invocation features";
    case physcl_device_prvte_data_ftrs:
        return "physical device private data features";
    case device_prvte_data_create_info:
        return "device private data create info";
    case prvte_data_slot_create_info:
        return "private data slot create info";
    case physcl_device_pplne_crtn_cache_cntrl_ftrs:
        return "physical device pipeline creation cache control features";
    case memory_brrr_2:
        return "memory barrier 2";
    case buffer_memory_brrr_2:
        return "buffer memory barrier 2";
    case img_memory_brrr_2:
        return "image memory barrier 2";
    case dpndncy_info:
        return "dependency info";
    case submit_info_2:
        return "submit info 2";
    case smphre_submit_info:
        return "semaphore submit info";
    case cmmnd_buffer_submit_info:
        return "command buffer submit info";
    case physcl_device_synchrn_2_ftrs:
        return "physical device synchronization 2 features";
    case physcl_device_zero_intlze_wrkgrp_memory_ftrs:
        return "physical device zero initialize workgroup memory features";
    case physcl_device_img_rbstns_ftrs:
        return "physical device image robustness features";
    case copy_buffer_info_2:
        return "copy buffer info 2";
    case copy_img_info_2:
        return "copy image info 2";
    case copy_buffer_to_img_info_2:
        return "copy buffer to image info 2";
    case copy_img_to_buffer_info_2:
        return "copy image to buffer info 2";
    case blit_img_info_2:
        return "blit image info 2";
    case rslve_img_info_2:
        return "resolve image info 2";
    case buffer_copy_2:
        return "buffer copy 2";
    case img_copy_2:
        return "image copy 2";
    case img_blit_2:
        return "image blit 2";
    case buffer_img_copy_2:
        return "buffer image copy 2";
    case img_rslve_2:
        return "image resolve 2";
    case physcl_device_sbgrp_size_cntrl_prprts:
        return "physical device subgroup size control properties";
    case pplne_shader_stage_rqrd_sbgrp_size_create_info:
        return "pipeline shader stage required subgroup size create info";
    case physcl_device_sbgrp_size_cntrl_ftrs:
        return "physical device subgroup size control features";
    case physcl_device_inline_unfrm_block_ftrs:
        return "physical device inline uniform block features";
    case physcl_device_inline_unfrm_block_prprts:
        return "physical device inline uniform block properties";
    case write_dscrpt_set_inline_unfrm_block:
        return "write descriptor set inline uniform block";
    case dscrpt_pool_inline_unfrm_block_create_info:
        return "descriptor pool inline uniform block create info";
    case physcl_device_txtre_cmprssn_astc_hdr_ftrs:
        return "physical device texture compression astc hdr features";
    case rndrng_info:
        return "rendering info";
    case rndrng_attchmt_info:
        return "rendering attachment info";
    case pplne_rndrng_create_info:
        return "pipeline rendering create info";
    case physcl_device_dynmc_rndrng_ftrs:
        return "physical device dynamic rendering features";
    case cmmnd_buffer_inhrtn_rndrng_info:
        return "command buffer inheritance rendering info";
    case physcl_device_shader_intgr_dot_prdct_ftrs:
        return "physical device shader integer dot product features";
    case physcl_device_shader_intgr_dot_prdct_prprts:
        return "physical device shader integer dot product properties";
    case physcl_device_texel_buffer_algnmnt_prprts:
        return "physical device texel buffer alignment properties";
    case format_prprts_3:
        return "format properties 3";
    case physcl_device_mntnnc_4_ftrs:
        return "physical device maintenance 4 features";
    case physcl_device_mntnnc_4_prprts:
        return "physical device maintenance 4 properties";
    case device_buffer_memory_rqrmnts:
        return "device buffer memory requirements";
    case device_img_memory_rqrmnts:
        return "device image memory requirements";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string strctr_type_str(VkStructureType val)
{
    return strctr_type_str(static_cast<StructureType>(val));
}

/*!
 * \brief Maps to VkSubpassContents. Should be safe to static_cast between.
 */
enum class SubpassContents {
    inlne = VK_SUBPASS_CONTENTS_INLINE,
    scndry_cmmnd_bffrs = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
};

constexpr std::string sbpss_cntnts_str(SubpassContents val)
{
    using enum SubpassContents;

    switch(val) {
    case inlne:
        return "inline";
    case scndry_cmmnd_bffrs:
        return "secondary command buffers";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string sbpss_cntnts_str(VkSubpassContents val)
{
    return sbpss_cntnts_str(static_cast<SubpassContents>(val));
}

/*!
 * \brief Maps to VkResult. Should be safe to static_cast between.
 */
enum class Result {
    sccss = VK_SUCCESS,
    not_ready = VK_NOT_READY,
    tmt = VK_TIMEOUT,
    event_set = VK_EVENT_SET,
    event_reset = VK_EVENT_RESET,
    incmpl = VK_INCOMPLETE,
    error_out_of_host_memory = VK_ERROR_OUT_OF_HOST_MEMORY,
    error_out_of_device_memory = VK_ERROR_OUT_OF_DEVICE_MEMORY,
    error_intlztn_failed = VK_ERROR_INITIALIZATION_FAILED,
    error_device_lost = VK_ERROR_DEVICE_LOST,
    error_memory_map_failed = VK_ERROR_MEMORY_MAP_FAILED,
    error_layer_not_prsnt = VK_ERROR_LAYER_NOT_PRESENT,
    error_extnsn_not_prsnt = VK_ERROR_EXTENSION_NOT_PRESENT,
    error_ftre_not_prsnt = VK_ERROR_FEATURE_NOT_PRESENT,
    error_incmptl_driver = VK_ERROR_INCOMPATIBLE_DRIVER,
    error_too_many_objcts = VK_ERROR_TOO_MANY_OBJECTS,
    error_format_not_spprtd = VK_ERROR_FORMAT_NOT_SUPPORTED,
    error_frgmntd_pool = VK_ERROR_FRAGMENTED_POOL,
    error_unknwn = VK_ERROR_UNKNOWN,
    error_out_of_pool_memory = VK_ERROR_OUT_OF_POOL_MEMORY,
    error_invld_extrnl_handle = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    error_frgmntn = VK_ERROR_FRAGMENTATION,
    error_invld_opaque_cptre_addrss = VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,
    pplne_cmple_rqrd = VK_PIPELINE_COMPILE_REQUIRED,
};

constexpr std::string result_str(Result val)
{
    using enum Result;

    switch(val) {
    case sccss:
        return "success";
    case not_ready:
        return "not ready";
    case tmt:
        return "timeout";
    case event_set:
        return "event set";
    case event_reset:
        return "event reset";
    case incmpl:
        return "incomplete";
    case error_out_of_host_memory:
        return "error out of host memory";
    case error_out_of_device_memory:
        return "error out of device memory";
    case error_intlztn_failed:
        return "error initialization failed";
    case error_device_lost:
        return "error device lost";
    case error_memory_map_failed:
        return "error memory map failed";
    case error_layer_not_prsnt:
        return "error layer not present";
    case error_extnsn_not_prsnt:
        return "error extension not present";
    case error_ftre_not_prsnt:
        return "error feature not present";
    case error_incmptl_driver:
        return "error incompatible driver";
    case error_too_many_objcts:
        return "error too many objects";
    case error_format_not_spprtd:
        return "error format not supported";
    case error_frgmntd_pool:
        return "error fragmented pool";
    case error_unknwn:
        return "error unknown";
    case error_out_of_pool_memory:
        return "error out of pool memory";
    case error_invld_extrnl_handle:
        return "error invalid external handle";
    case error_frgmntn:
        return "error fragmentation";
    case error_invld_opaque_cptre_addrss:
        return "error invalid opaque capture address";
    case pplne_cmple_rqrd:
        return "pipeline compile required";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string result_str(VkResult val)
{
    return result_str(static_cast<Result>(val));
}

/*!
 * \brief Maps to VkDynamicState. Should be safe to static_cast between.
 */
enum class DynamicState {
    vwprt = VK_DYNAMIC_STATE_VIEWPORT,
    scssr = VK_DYNAMIC_STATE_SCISSOR,
    line_width = VK_DYNAMIC_STATE_LINE_WIDTH,
    depth_bias = VK_DYNAMIC_STATE_DEPTH_BIAS,
    blend_cnstnts = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    depth_bounds = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    stncl_cmpre_mask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    stncl_write_mask = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    stncl_rfrnce = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    cull_mode = VK_DYNAMIC_STATE_CULL_MODE,
    front_face = VK_DYNAMIC_STATE_FRONT_FACE,
    prmtve_tplgy = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
    vwprt_with_count = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
    scssr_with_count = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
    vertex_input_bndng_stride = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
    depth_test_enable = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    depth_write_enable = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    depth_cmpre_op = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    depth_bounds_test_enable = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    stncl_test_enable = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
    stncl_op = VK_DYNAMIC_STATE_STENCIL_OP,
    rstrzr_dscrd_enable = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
    depth_bias_enable = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
    prmtve_rstrt_enable = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
};

constexpr std::string dynmc_state_str(DynamicState val)
{
    using enum DynamicState;

    switch(val) {
    case vwprt:
        return "viewport";
    case scssr:
        return "scissor";
    case line_width:
        return "line width";
    case depth_bias:
        return "depth bias";
    case blend_cnstnts:
        return "blend constants";
    case depth_bounds:
        return "depth bounds";
    case stncl_cmpre_mask:
        return "stencil compare mask";
    case stncl_write_mask:
        return "stencil write mask";
    case stncl_rfrnce:
        return "stencil reference";
    case cull_mode:
        return "cull mode";
    case front_face:
        return "front face";
    case prmtve_tplgy:
        return "primitive topology";
    case vwprt_with_count:
        return "viewport with count";
    case scssr_with_count:
        return "scissor with count";
    case vertex_input_bndng_stride:
        return "vertex input binding stride";
    case depth_test_enable:
        return "depth test enable";
    case depth_write_enable:
        return "depth write enable";
    case depth_cmpre_op:
        return "depth compare op";
    case depth_bounds_test_enable:
        return "depth bounds test enable";
    case stncl_test_enable:
        return "stencil test enable";
    case stncl_op:
        return "stencil op";
    case rstrzr_dscrd_enable:
        return "rasterizer discard enable";
    case depth_bias_enable:
        return "depth bias enable";
    case prmtve_rstrt_enable:
        return "primitive restart enable";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dynmc_state_str(VkDynamicState val)
{
    return dynmc_state_str(static_cast<DynamicState>(val));
}

/*!
 * \brief Maps to VkDescriptorUpdateTemplateType. Should be safe to static_cast between.
 */
enum class DescriptorUpdateTemplateType {
    dscrpt_set = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
};

constexpr std::string dscrpt_update_tmplte_type_str(DescriptorUpdateTemplateType val)
{
    using enum DescriptorUpdateTemplateType;

    switch(val) {
    case dscrpt_set:
        return "descriptor set";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dscrpt_update_tmplte_type_str(VkDescriptorUpdateTemplateType val)
{
    return dscrpt_update_tmplte_type_str(static_cast<DescriptorUpdateTemplateType>(val));
}

/*!
 * \brief Maps to VkObjectType. Should be safe to static_cast between.
 */
enum class ObjectType {
    unknwn = VK_OBJECT_TYPE_UNKNOWN,
    instnc = VK_OBJECT_TYPE_INSTANCE,
    physcl_device = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    device = VK_OBJECT_TYPE_DEVICE,
    queue = VK_OBJECT_TYPE_QUEUE,
    smphre = VK_OBJECT_TYPE_SEMAPHORE,
    cmmnd_buffer = VK_OBJECT_TYPE_COMMAND_BUFFER,
    fence = VK_OBJECT_TYPE_FENCE,
    device_memory = VK_OBJECT_TYPE_DEVICE_MEMORY,
    buffer = VK_OBJECT_TYPE_BUFFER,
    img = VK_OBJECT_TYPE_IMAGE,
    event = VK_OBJECT_TYPE_EVENT,
    query_pool = VK_OBJECT_TYPE_QUERY_POOL,
    buffer_view = VK_OBJECT_TYPE_BUFFER_VIEW,
    img_view = VK_OBJECT_TYPE_IMAGE_VIEW,
    shader_module = VK_OBJECT_TYPE_SHADER_MODULE,
    pplne_cache = VK_OBJECT_TYPE_PIPELINE_CACHE,
    pplne_layout = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    render_pass = VK_OBJECT_TYPE_RENDER_PASS,
    pplne = VK_OBJECT_TYPE_PIPELINE,
    dscrpt_set_layout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    smplr = VK_OBJECT_TYPE_SAMPLER,
    dscrpt_pool = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    dscrpt_set = VK_OBJECT_TYPE_DESCRIPTOR_SET,
    frmbff = VK_OBJECT_TYPE_FRAMEBUFFER,
    cmmnd_pool = VK_OBJECT_TYPE_COMMAND_POOL,
    smplr_ycbcr_cnvrsn = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    dscrpt_update_tmplte = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    prvte_data_slot = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
};

constexpr std::string object_type_str(ObjectType val)
{
    using enum ObjectType;

    switch(val) {
    case unknwn:
        return "unknown";
    case instnc:
        return "instance";
    case physcl_device:
        return "physical device";
    case device:
        return "device";
    case queue:
        return "queue";
    case smphre:
        return "semaphore";
    case cmmnd_buffer:
        return "command buffer";
    case fence:
        return "fence";
    case device_memory:
        return "device memory";
    case buffer:
        return "buffer";
    case img:
        return "image";
    case event:
        return "event";
    case query_pool:
        return "query pool";
    case buffer_view:
        return "buffer view";
    case img_view:
        return "image view";
    case shader_module:
        return "shader module";
    case pplne_cache:
        return "pipeline cache";
    case pplne_layout:
        return "pipeline layout";
    case render_pass:
        return "render pass";
    case pplne:
        return "pipeline";
    case dscrpt_set_layout:
        return "descriptor set layout";
    case smplr:
        return "sampler";
    case dscrpt_pool:
        return "descriptor pool";
    case dscrpt_set:
        return "descriptor set";
    case frmbff:
        return "framebuffer";
    case cmmnd_pool:
        return "command pool";
    case smplr_ycbcr_cnvrsn:
        return "sampler ycbcr conversion";
    case dscrpt_update_tmplte:
        return "descriptor update template";
    case prvte_data_slot:
        return "private data slot";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string object_type_str(VkObjectType val)
{
    return object_type_str(static_cast<ObjectType>(val));
}

/*!
 * \brief Maps to VkSemaphoreType. Should be safe to static_cast between.
 */
enum class SemaphoreType {
    binary = VK_SEMAPHORE_TYPE_BINARY,
    tmlne = VK_SEMAPHORE_TYPE_TIMELINE,
};

constexpr std::string smphre_type_str(SemaphoreType val)
{
    using enum SemaphoreType;

    switch(val) {
    case binary:
        return "binary";
    case tmlne:
        return "timeline";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smphre_type_str(VkSemaphoreType val)
{
    return smphre_type_str(static_cast<SemaphoreType>(val));
}

/*!
 * \brief Maps to VkPresentModeKHR. Should be safe to static_cast between.
 */
enum class PresentMode {
    immdte = VK_PRESENT_MODE_IMMEDIATE_KHR,
    mlbx = VK_PRESENT_MODE_MAILBOX_KHR,
    FIFO = VK_PRESENT_MODE_FIFO_KHR,
    FIFO_rlxd = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
};

constexpr std::string prsnt_mode_str(PresentMode val)
{
    using enum PresentMode;

    switch(val) {
    case immdte:
        return "immediate";
    case mlbx:
        return "mailbox";
    case FIFO:
        return "FIFO";
    case FIFO_rlxd:
        return "FIFO relaxed";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prsnt_mode_str(VkPresentModeKHR val)
{
    return prsnt_mode_str(static_cast<PresentMode>(val));
}

/*!
 * \brief Maps to VkColorSpaceKHR. Should be safe to static_cast between.
 */
enum class ColorSpace {
    srgb_nnlnr = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
};

constexpr std::string color_space_str(ColorSpace val)
{
    using enum ColorSpace;

    switch(val) {
    case srgb_nnlnr:
        return "sRGB nonlinear";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string color_space_str(VkColorSpaceKHR val)
{
    return color_space_str(static_cast<ColorSpace>(val));
}

/*!
 * \brief Maps to VkPointClippingBehavior. Should be safe to static_cast between.
 */
enum class PointClippingBehavior {
    all_clip_planes = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    user_clip_planes_only = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
};

constexpr std::string point_clppng_bhvr_str(PointClippingBehavior val)
{
    using enum PointClippingBehavior;

    switch(val) {
    case all_clip_planes:
        return "all clip planes";
    case user_clip_planes_only:
        return "user clip planes only";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string point_clppng_bhvr_str(VkPointClippingBehavior val)
{
    return point_clppng_bhvr_str(static_cast<PointClippingBehavior>(val));
}

/*!
 * \brief Maps to VkSamplerReductionMode. Should be safe to static_cast between.
 */
enum class SamplerReductionMode {
    wghtd_avrge = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
    min = VK_SAMPLER_REDUCTION_MODE_MIN,
    max = VK_SAMPLER_REDUCTION_MODE_MAX,
};

constexpr std::string smplr_rdctn_mode_str(SamplerReductionMode val)
{
    using enum SamplerReductionMode;

    switch(val) {
    case wghtd_avrge:
        return "weighted average";
    case min:
        return "min";
    case max:
        return "max";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smplr_rdctn_mode_str(VkSamplerReductionMode val)
{
    return smplr_rdctn_mode_str(static_cast<SamplerReductionMode>(val));
}

/*!
 * \brief Maps to VkTessellationDomainOrigin. Should be safe to static_cast between.
 */
enum class TessellationDomainOrigin {
    upper_left = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    lower_left = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
};

constexpr std::string tsslltn_domain_origin_str(TessellationDomainOrigin val)
{
    using enum TessellationDomainOrigin;

    switch(val) {
    case upper_left:
        return "upper left";
    case lower_left:
        return "lower left";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string tsslltn_domain_origin_str(VkTessellationDomainOrigin val)
{
    return tsslltn_domain_origin_str(static_cast<TessellationDomainOrigin>(val));
}

/*!
 * \brief Maps to VkSamplerYcbcrModelConversion. Should be safe to static_cast between.
 */
enum class SamplerYcbcrModelConversion {
    rgb_idntty = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    ycbcr_idntty = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    ycbcr_709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    ycbcr_601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    ycbcr_2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
};

constexpr std::string smplr_ycbcr_model_cnvrsn_str(SamplerYcbcrModelConversion val)
{
    using enum SamplerYcbcrModelConversion;

    switch(val) {
    case rgb_idntty:
        return "rgb identity";
    case ycbcr_idntty:
        return "ycbcr identity";
    case ycbcr_709:
        return "ycbcr 709";
    case ycbcr_601:
        return "ycbcr 601";
    case ycbcr_2020:
        return "ycbcr 2020";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smplr_ycbcr_model_cnvrsn_str(VkSamplerYcbcrModelConversion val)
{
    return smplr_ycbcr_model_cnvrsn_str(static_cast<SamplerYcbcrModelConversion>(val));
}

/*!
 * \brief Maps to VkSamplerYcbcrRange. Should be safe to static_cast between.
 */
enum class SamplerYcbcrRange {
    itu_full = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    itu_narrow = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
};

constexpr std::string smplr_ycbcr_range_str(SamplerYcbcrRange val)
{
    using enum SamplerYcbcrRange;

    switch(val) {
    case itu_full:
        return "itu full";
    case itu_narrow:
        return "itu narrow";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smplr_ycbcr_range_str(VkSamplerYcbcrRange val)
{
    return smplr_ycbcr_range_str(static_cast<SamplerYcbcrRange>(val));
}

/*!
 * \brief Maps to VkChromaLocation. Should be safe to static_cast between.
 */
enum class ChromaLocation {
    cstd_even = VK_CHROMA_LOCATION_COSITED_EVEN,
    mdpnt = VK_CHROMA_LOCATION_MIDPOINT,
};

constexpr std::string chroma_lctn_str(ChromaLocation val)
{
    using enum ChromaLocation;

    switch(val) {
    case cstd_even:
        return "cosited even";
    case mdpnt:
        return "midpoint";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string chroma_lctn_str(VkChromaLocation val)
{
    return chroma_lctn_str(static_cast<ChromaLocation>(val));
}

/*!
 * \brief Maps to VkQueueGlobalPriorityKHR. Should be safe to static_cast between.
 */
enum class QueueGlobalPriority {
    low = VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR,
    medium = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR,
    high = VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR,
    rltme = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR,
};

constexpr std::string queue_global_prrty_str(QueueGlobalPriority val)
{
    using enum QueueGlobalPriority;

    switch(val) {
    case low:
        return "low";
    case medium:
        return "medium";
    case high:
        return "high";
    case rltme:
        return "realtime";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string queue_global_prrty_str(VkQueueGlobalPriorityKHR val)
{
    return queue_global_prrty_str(static_cast<QueueGlobalPriority>(val));
}

/*!
 * \brief Maps to VkVendorId. Should be safe to static_cast between.
 */
enum class VendorId {
    viv = VK_VENDOR_ID_VIV,
    vsi = VK_VENDOR_ID_VSI,
    kazan = VK_VENDOR_ID_KAZAN,
    cdply = VK_VENDOR_ID_CODEPLAY,
    mesa = VK_VENDOR_ID_MESA,
    pocl = VK_VENDOR_ID_POCL,
};

constexpr std::string vendor_id_str(VendorId val)
{
    using enum VendorId;

    switch(val) {
    case viv:
        return "viv";
    case vsi:
        return "vsi";
    case kazan:
        return "kazan";
    case cdply:
        return "codeplay";
    case mesa:
        return "mesa";
    case pocl:
        return "pocl";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string vendor_id_str(VkVendorId val)
{
    return vendor_id_str(static_cast<VendorId>(val));
}

/*!
 * \brief Maps to VkDriverId. Should be safe to static_cast between.
 */
enum class DriverId {
    amd_prprtry = VK_DRIVER_ID_AMD_PROPRIETARY,
    amd_open_source = VK_DRIVER_ID_AMD_OPEN_SOURCE,
    mesa_radv = VK_DRIVER_ID_MESA_RADV,
    nvidia_prprtry = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
    intel_prprtry_wndws = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
    intel_open_source_mesa = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
    imgntn_prprtry = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
    qlcmm_prprtry = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
    arm_prprtry = VK_DRIVER_ID_ARM_PROPRIETARY,
    google_swftsh = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
    ggp_prprtry = VK_DRIVER_ID_GGP_PROPRIETARY,
    brdcm_prprtry = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
    mesa_llvmpp = VK_DRIVER_ID_MESA_LLVMPIPE,
    mltnvk = VK_DRIVER_ID_MOLTENVK,
    crvi_prprtry = VK_DRIVER_ID_COREAVI_PROPRIETARY,
    juice_prprtry = VK_DRIVER_ID_JUICE_PROPRIETARY,
    vrslcn_prprtry = VK_DRIVER_ID_VERISILICON_PROPRIETARY,
    mesa_turnip = VK_DRIVER_ID_MESA_TURNIP,
    mesa_vthrDv = VK_DRIVER_ID_MESA_V3DV,
    mesa_panvk = VK_DRIVER_ID_MESA_PANVK,
    smsng_prprtry = VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
    mesa_venus = VK_DRIVER_ID_MESA_VENUS,
    mesa_dozen = VK_DRIVER_ID_MESA_DOZEN,
};

constexpr std::string driver_id_str(DriverId val)
{
    using enum DriverId;

    switch(val) {
    case amd_prprtry:
        return "amd proprietary";
    case amd_open_source:
        return "amd open source";
    case mesa_radv:
        return "mesa radv";
    case nvidia_prprtry:
        return "nvidia proprietary";
    case intel_prprtry_wndws:
        return "intel proprietary windows";
    case intel_open_source_mesa:
        return "intel open source mesa";
    case imgntn_prprtry:
        return "imagination proprietary";
    case qlcmm_prprtry:
        return "qualcomm proprietary";
    case arm_prprtry:
        return "arm proprietary";
    case google_swftsh:
        return "google swiftshader";
    case ggp_prprtry:
        return "ggp proprietary";
    case brdcm_prprtry:
        return "broadcom proprietary";
    case mesa_llvmpp:
        return "mesa llvmpipe";
    case mltnvk:
        return "moltenvk";
    case crvi_prprtry:
        return "coreavi proprietary";
    case juice_prprtry:
        return "juice proprietary";
    case vrslcn_prprtry:
        return "verisilicon proprietary";
    case mesa_turnip:
        return "mesa turnip";
    case mesa_vthrDv:
        return "mesa vthreedv";
    case mesa_panvk:
        return "mesa panvk";
    case smsng_prprtry:
        return "samsung proprietary";
    case mesa_venus:
        return "mesa venus";
    case mesa_dozen:
        return "mesa dozen";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string driver_id_str(VkDriverId val)
{
    return driver_id_str(static_cast<DriverId>(val));
}

/*!
 * \brief Maps to VkCopyAccelerationStructureModeKHR. Should be safe to static_cast between.
 */
enum class CopyAccelerationStructureMode {
    clone = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
    cmpct = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    srlze = VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
    dsrlze = VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
};

constexpr std::string copy_acclrtn_strctr_mode_str(CopyAccelerationStructureMode val)
{
    using enum CopyAccelerationStructureMode;

    switch(val) {
    case clone:
        return "clone";
    case cmpct:
        return "compact";
    case srlze:
        return "serialize";
    case dsrlze:
        return "deserialize";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string copy_acclrtn_strctr_mode_str(VkCopyAccelerationStructureModeKHR val)
{
    return copy_acclrtn_strctr_mode_str(static_cast<CopyAccelerationStructureMode>(val));
}

/*!
 * \brief Maps to VkBuildAccelerationStructureModeKHR. Should be safe to static_cast between.
 */
enum class BuildAccelerationStructureMode {
    build = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
    update = VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
};

constexpr std::string build_acclrtn_strctr_mode_str(BuildAccelerationStructureMode val)
{
    using enum BuildAccelerationStructureMode;

    switch(val) {
    case build:
        return "build";
    case update:
        return "update";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string build_acclrtn_strctr_mode_str(VkBuildAccelerationStructureModeKHR val)
{
    return build_acclrtn_strctr_mode_str(static_cast<BuildAccelerationStructureMode>(val));
}

/*!
 * \brief Maps to VkAccelerationStructureTypeKHR. Should be safe to static_cast between.
 */
enum class AccelerationStructureType {
    top_level = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    bottom_level = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
    gnrc = VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
};

constexpr std::string acclrtn_strctr_type_str(AccelerationStructureType val)
{
    using enum AccelerationStructureType;

    switch(val) {
    case top_level:
        return "top level";
    case bottom_level:
        return "bottom level";
    case gnrc:
        return "generic";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string acclrtn_strctr_type_str(VkAccelerationStructureTypeKHR val)
{
    return acclrtn_strctr_type_str(static_cast<AccelerationStructureType>(val));
}

/*!
 * \brief Maps to VkGeometryTypeKHR. Should be safe to static_cast between.
 */
enum class GeometryType {
    trngls = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    aabbs = VK_GEOMETRY_TYPE_AABBS_KHR,
    instncs = VK_GEOMETRY_TYPE_INSTANCES_KHR,
};

constexpr std::string gmtry_type_str(GeometryType val)
{
    using enum GeometryType;

    switch(val) {
    case trngls:
        return "triangles";
    case aabbs:
        return "aabbs";
    case instncs:
        return "instances";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string gmtry_type_str(VkGeometryTypeKHR val)
{
    return gmtry_type_str(static_cast<GeometryType>(val));
}

/*!
 * \brief Maps to VkAccelerationStructureBuildTypeKHR. Should be safe to static_cast between.
 */
enum class AccelerationStructureBuildType {
    host = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
    device = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
    host_or_device = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
};

constexpr std::string acclrtn_strctr_build_type_str(AccelerationStructureBuildType val)
{
    using enum AccelerationStructureBuildType;

    switch(val) {
    case host:
        return "host";
    case device:
        return "device";
    case host_or_device:
        return "host or device";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string acclrtn_strctr_build_type_str(VkAccelerationStructureBuildTypeKHR val)
{
    return acclrtn_strctr_build_type_str(static_cast<AccelerationStructureBuildType>(val));
}

/*!
 * \brief Maps to VkRayTracingShaderGroupTypeKHR. Should be safe to static_cast between.
 */
enum class RayTracingShaderGroupType {
    gnrl = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
    trngls_hit_group = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
    prcdrl_hit_group = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
};

constexpr std::string ray_trcng_shader_group_type_str(RayTracingShaderGroupType val)
{
    using enum RayTracingShaderGroupType;

    switch(val) {
    case gnrl:
        return "general";
    case trngls_hit_group:
        return "triangles hit group";
    case prcdrl_hit_group:
        return "procedural hit group";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string ray_trcng_shader_group_type_str(VkRayTracingShaderGroupTypeKHR val)
{
    return ray_trcng_shader_group_type_str(static_cast<RayTracingShaderGroupType>(val));
}

/*!
 * \brief Maps to VkAccelerationStructureCompatibilityKHR. Should be safe to static_cast between.
 */
enum class AccelerationStructureCompatibility {
    cmptbl = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
    incmptl = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
};

constexpr std::string acclrtn_strctr_cmptbly_str(AccelerationStructureCompatibility val)
{
    using enum AccelerationStructureCompatibility;

    switch(val) {
    case cmptbl:
        return "compatible";
    case incmptl:
        return "incompatible";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string acclrtn_strctr_cmptbly_str(VkAccelerationStructureCompatibilityKHR val)
{
    return acclrtn_strctr_cmptbly_str(static_cast<AccelerationStructureCompatibility>(val));
}

/*!
 * \brief Maps to VkShaderGroupShaderKHR. Should be safe to static_cast between.
 */
enum class ShaderGroupShader {
    gnrl = VK_SHADER_GROUP_SHADER_GENERAL_KHR,
    clsst_hit = VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
    any_hit = VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
    intrscn = VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
};

constexpr std::string shader_group_shader_str(ShaderGroupShader val)
{
    using enum ShaderGroupShader;

    switch(val) {
    case gnrl:
        return "general";
    case clsst_hit:
        return "closest hit";
    case any_hit:
        return "any hit";
    case intrscn:
        return "intersection";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string shader_group_shader_str(VkShaderGroupShaderKHR val)
{
    return shader_group_shader_str(static_cast<ShaderGroupShader>(val));
}

/*!
 * \brief Maps to VkPerformanceCounterScopeKHR. Should be safe to static_cast between.
 */
enum class PerformanceCounterScope {
    cmmnd_buffer = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
    render_pass = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
    cmmnd = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
};

constexpr std::string prfrmn_cntr_scope_str(PerformanceCounterScope val)
{
    using enum PerformanceCounterScope;

    switch(val) {
    case cmmnd_buffer:
        return "command buffer";
    case render_pass:
        return "render pass";
    case cmmnd:
        return "command";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prfrmn_cntr_scope_str(VkPerformanceCounterScopeKHR val)
{
    return prfrmn_cntr_scope_str(static_cast<PerformanceCounterScope>(val));
}

/*!
 * \brief Maps to VkPerformanceCounterUnitKHR. Should be safe to static_cast between.
 */
enum class PerformanceCounterUnit {
    gnrc = VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
    prcntg = VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
    nnscnds = VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
    bytes = VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
    bytes_per_second = VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
    kelvin = VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
    watts = VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
    volts = VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
    amps = VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
    hertz = VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
    cycles = VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
};

constexpr std::string prfrmn_cntr_unit_str(PerformanceCounterUnit val)
{
    using enum PerformanceCounterUnit;

    switch(val) {
    case gnrc:
        return "generic";
    case prcntg:
        return "percentage";
    case nnscnds:
        return "nanoseconds";
    case bytes:
        return "bytes";
    case bytes_per_second:
        return "bytes per second";
    case kelvin:
        return "kelvin";
    case watts:
        return "watts";
    case volts:
        return "volts";
    case amps:
        return "amps";
    case hertz:
        return "hertz";
    case cycles:
        return "cycles";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prfrmn_cntr_unit_str(VkPerformanceCounterUnitKHR val)
{
    return prfrmn_cntr_unit_str(static_cast<PerformanceCounterUnit>(val));
}

/*!
 * \brief Maps to VkPerformanceCounterStorageKHR. Should be safe to static_cast between.
 */
enum class PerformanceCounterStorage {
    int32 = VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
    int64 = VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
    uint32 = VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
    uint64 = VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
    float32 = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
    float64 = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
};

constexpr std::string prfrmn_cntr_strge_str(PerformanceCounterStorage val)
{
    using enum PerformanceCounterStorage;

    switch(val) {
    case int32:
        return "int32";
    case int64:
        return "int64";
    case uint32:
        return "uint32";
    case uint64:
        return "uint64";
    case float32:
        return "float32";
    case float64:
        return "float64";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prfrmn_cntr_strge_str(VkPerformanceCounterStorageKHR val)
{
    return prfrmn_cntr_strge_str(static_cast<PerformanceCounterStorage>(val));
}

/*!
 * \brief Maps to VkShaderFloatControlsIndependence. Should be safe to static_cast between.
 */
enum class ShaderFloatControlsIndependence {
    thrtytw_bit_only = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    all = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
    none = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
};

constexpr std::string shader_float_cntrls_indpnd_str(ShaderFloatControlsIndependence val)
{
    using enum ShaderFloatControlsIndependence;

    switch(val) {
    case thrtytw_bit_only:
        return "32 bit only";
    case all:
        return "all";
    case none:
        return "none";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string shader_float_cntrls_indpnd_str(VkShaderFloatControlsIndependence val)
{
    return shader_float_cntrls_indpnd_str(static_cast<ShaderFloatControlsIndependence>(val));
}

/*!
 * \brief Maps to VkPipelineExecutableStatisticFormatKHR. Should be safe to static_cast between.
 */
enum class PipelineExecutableStatisticFormat {
    bool32 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
    int64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
    uint64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
    float64 = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
};

constexpr std::string pplne_exctbl_sttstc_format_str(PipelineExecutableStatisticFormat val)
{
    using enum PipelineExecutableStatisticFormat;

    switch(val) {
    case bool32:
        return "bool32";
    case int64:
        return "int64";
    case uint64:
        return "uint64";
    case float64:
        return "float64";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_exctbl_sttstc_format_str(VkPipelineExecutableStatisticFormatKHR val)
{
    return pplne_exctbl_sttstc_format_str(static_cast<PipelineExecutableStatisticFormat>(val));
}

/*!
 * \brief Maps to VkFragmentShadingRateCombinerOpKHR. Should be safe to static_cast between.
 */
enum class FragmentShadingRateCombinerOp {
    keep = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
    rplce = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
    min = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
    max = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
    mul = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
};

constexpr std::string frgmnt_shdng_rate_cmbnr_op_str(FragmentShadingRateCombinerOp val)
{
    using enum FragmentShadingRateCombinerOp;

    switch(val) {
    case keep:
        return "keep";
    case rplce:
        return "replace";
    case min:
        return "min";
    case max:
        return "max";
    case mul:
        return "mul";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string frgmnt_shdng_rate_cmbnr_op_str(VkFragmentShadingRateCombinerOpKHR val)
{
    return frgmnt_shdng_rate_cmbnr_op_str(static_cast<FragmentShadingRateCombinerOp>(val));
}

/*!
 * \brief Maps to VkPipelineCacheCreateFlagBits. Should be safe to static_cast between.
 */
enum class PipelineCacheCreateFlag {
    extrnly_synchrd = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
};

constexpr std::string pplne_cache_create_flag_str(PipelineCacheCreateFlag val)
{
    using enum PipelineCacheCreateFlag;

    switch(val) {
    case extrnly_synchrd:
        return "externally synchronized";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_cache_create_flag_str(VkPipelineCacheCreateFlagBits val)
{
    return pplne_cache_create_flag_str(static_cast<PipelineCacheCreateFlag>(val));
}

using PipelineCacheCreateFlags = VkPipelineCacheCreateFlags;

constexpr std::vector<const char*> pplne_cache_create_flags_cstrs(VkPipelineCacheCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT) {
        cstrs.push_back("externally synchronized");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkQueueFlagBits. Should be safe to static_cast between.
 */
enum class QueueFlag {
    grphcs = VK_QUEUE_GRAPHICS_BIT,
    cmpte = VK_QUEUE_COMPUTE_BIT,
    trnsfr = VK_QUEUE_TRANSFER_BIT,
    sparse_bndng = VK_QUEUE_SPARSE_BINDING_BIT,
    prtctd = VK_QUEUE_PROTECTED_BIT,
};

constexpr std::string queue_flag_str(QueueFlag val)
{
    using enum QueueFlag;

    switch(val) {
    case grphcs:
        return "graphics";
    case cmpte:
        return "compute";
    case trnsfr:
        return "transfer";
    case sparse_bndng:
        return "sparse binding";
    case prtctd:
        return "protected";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string queue_flag_str(VkQueueFlagBits val)
{
    return queue_flag_str(static_cast<QueueFlag>(val));
}

using QueueFlags = VkQueueFlags;

constexpr std::vector<const char*> queue_flags_cstrs(VkQueueFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_QUEUE_GRAPHICS_BIT) {
        cstrs.push_back("graphics");
    }

    if (vals & VK_QUEUE_COMPUTE_BIT) {
        cstrs.push_back("compute");
    }

    if (vals & VK_QUEUE_TRANSFER_BIT) {
        cstrs.push_back("transfer");
    }

    if (vals & VK_QUEUE_SPARSE_BINDING_BIT) {
        cstrs.push_back("sparse binding");
    }

    if (vals & VK_QUEUE_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCullModeFlagBits. Should be safe to static_cast between.
 */
enum class CullModeFlag {
    none = VK_CULL_MODE_NONE,
    front = VK_CULL_MODE_FRONT_BIT,
    back = VK_CULL_MODE_BACK_BIT,
    front_and_back = VK_CULL_MODE_FRONT_AND_BACK,
};

constexpr std::string cull_mode_flag_str(CullModeFlag val)
{
    using enum CullModeFlag;

    switch(val) {
    case none:
        return "none";
    case front:
        return "front";
    case back:
        return "back";
    case front_and_back:
        return "front and back";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cull_mode_flag_str(VkCullModeFlagBits val)
{
    return cull_mode_flag_str(static_cast<CullModeFlag>(val));
}

using CullModeFlags = VkCullModeFlags;

constexpr std::vector<const char*> cull_mode_flags_cstrs(VkCullModeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_CULL_MODE_NONE) {
        cstrs.push_back("none");
    }

    if (vals & VK_CULL_MODE_FRONT_BIT) {
        cstrs.push_back("front");
    }

    if (vals & VK_CULL_MODE_BACK_BIT) {
        cstrs.push_back("back");
    }

    if (vals & VK_CULL_MODE_FRONT_AND_BACK) {
        cstrs.push_back("front and back");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDeviceQueueCreateFlagBits. Should be safe to static_cast between.
 */
enum class DeviceQueueCreateFlag {
    prtctd = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
};

constexpr std::string device_queue_create_flag_str(DeviceQueueCreateFlag val)
{
    using enum DeviceQueueCreateFlag;

    switch(val) {
    case prtctd:
        return "protected";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string device_queue_create_flag_str(VkDeviceQueueCreateFlagBits val)
{
    return device_queue_create_flag_str(static_cast<DeviceQueueCreateFlag>(val));
}

using DeviceQueueCreateFlags = VkDeviceQueueCreateFlags;

constexpr std::vector<const char*> device_queue_create_flags_cstrs(VkDeviceQueueCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkMemoryPropertyFlagBits. Should be safe to static_cast between.
 */
enum class MemoryPropertyFlag {
    device_local = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    host_vsble = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    host_chrnt = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    host_cached = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    lazily_allctd = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    prtctd = VK_MEMORY_PROPERTY_PROTECTED_BIT,
};

constexpr std::string memory_prprty_flag_str(MemoryPropertyFlag val)
{
    using enum MemoryPropertyFlag;

    switch(val) {
    case device_local:
        return "device local";
    case host_vsble:
        return "host visible";
    case host_chrnt:
        return "host coherent";
    case host_cached:
        return "host cached";
    case lazily_allctd:
        return "lazily allocated";
    case prtctd:
        return "protected";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string memory_prprty_flag_str(VkMemoryPropertyFlagBits val)
{
    return memory_prprty_flag_str(static_cast<MemoryPropertyFlag>(val));
}

using MemoryPropertyFlags = VkMemoryPropertyFlags;

constexpr std::vector<const char*> memory_prprty_flags_cstrs(VkMemoryPropertyFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) {
        cstrs.push_back("device local");
    }

    if (vals & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
        cstrs.push_back("host visible");
    }

    if (vals & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) {
        cstrs.push_back("host coherent");
    }

    if (vals & VK_MEMORY_PROPERTY_HOST_CACHED_BIT) {
        cstrs.push_back("host cached");
    }

    if (vals & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT) {
        cstrs.push_back("lazily allocated");
    }

    if (vals & VK_MEMORY_PROPERTY_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkMemoryHeapFlagBits. Should be safe to static_cast between.
 */
enum class MemoryHeapFlag {
    device_local = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    multi_instnc = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
};

constexpr std::string memory_heap_flag_str(MemoryHeapFlag val)
{
    using enum MemoryHeapFlag;

    switch(val) {
    case device_local:
        return "device local";
    case multi_instnc:
        return "multi instance";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string memory_heap_flag_str(VkMemoryHeapFlagBits val)
{
    return memory_heap_flag_str(static_cast<MemoryHeapFlag>(val));
}

using MemoryHeapFlags = VkMemoryHeapFlags;

constexpr std::vector<const char*> memory_heap_flags_cstrs(VkMemoryHeapFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) {
        cstrs.push_back("device local");
    }

    if (vals & VK_MEMORY_HEAP_MULTI_INSTANCE_BIT) {
        cstrs.push_back("multi instance");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkAccessFlagBits. Should be safe to static_cast between.
 */
enum class AccessFlag {
    indrct_cmmnd_read = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    index_read = VK_ACCESS_INDEX_READ_BIT,
    vertex_attrbt_read = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    unfrm_read = VK_ACCESS_UNIFORM_READ_BIT,
    input_attchmt_read = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    shader_read = VK_ACCESS_SHADER_READ_BIT,
    shader_write = VK_ACCESS_SHADER_WRITE_BIT,
    color_attchmt_read = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    color_attchmt_write = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    depth_stncl_attchmt_read = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    depth_stncl_attchmt_write = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    trnsfr_read = VK_ACCESS_TRANSFER_READ_BIT,
    trnsfr_write = VK_ACCESS_TRANSFER_WRITE_BIT,
    host_read = VK_ACCESS_HOST_READ_BIT,
    host_write = VK_ACCESS_HOST_WRITE_BIT,
    memory_read = VK_ACCESS_MEMORY_READ_BIT,
    memory_write = VK_ACCESS_MEMORY_WRITE_BIT,
    none = VK_ACCESS_NONE,
};

constexpr std::string access_flag_str(AccessFlag val)
{
    using enum AccessFlag;

    switch(val) {
    case indrct_cmmnd_read:
        return "indirect command read";
    case index_read:
        return "index read";
    case vertex_attrbt_read:
        return "vertex attribute read";
    case unfrm_read:
        return "uniform read";
    case input_attchmt_read:
        return "input attachment read";
    case shader_read:
        return "shader read";
    case shader_write:
        return "shader write";
    case color_attchmt_read:
        return "color attachment read";
    case color_attchmt_write:
        return "color attachment write";
    case depth_stncl_attchmt_read:
        return "depth/stencil attachment read";
    case depth_stncl_attchmt_write:
        return "depth/stencil attachment write";
    case trnsfr_read:
        return "transfer read";
    case trnsfr_write:
        return "transfer write";
    case host_read:
        return "host read";
    case host_write:
        return "host write";
    case memory_read:
        return "memory read";
    case memory_write:
        return "memory write";
    case none:
        return "none";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string access_flag_str(VkAccessFlagBits val)
{
    return access_flag_str(static_cast<AccessFlag>(val));
}

using AccessFlags = VkAccessFlags;

constexpr std::vector<const char*> access_flags_cstrs(VkAccessFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_ACCESS_INDIRECT_COMMAND_READ_BIT) {
        cstrs.push_back("indirect command read");
    }

    if (vals & VK_ACCESS_INDEX_READ_BIT) {
        cstrs.push_back("index read");
    }

    if (vals & VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT) {
        cstrs.push_back("vertex attribute read");
    }

    if (vals & VK_ACCESS_UNIFORM_READ_BIT) {
        cstrs.push_back("uniform read");
    }

    if (vals & VK_ACCESS_INPUT_ATTACHMENT_READ_BIT) {
        cstrs.push_back("input attachment read");
    }

    if (vals & VK_ACCESS_SHADER_READ_BIT) {
        cstrs.push_back("shader read");
    }

    if (vals & VK_ACCESS_SHADER_WRITE_BIT) {
        cstrs.push_back("shader write");
    }

    if (vals & VK_ACCESS_COLOR_ATTACHMENT_READ_BIT) {
        cstrs.push_back("color attachment read");
    }

    if (vals & VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT) {
        cstrs.push_back("color attachment write");
    }

    if (vals & VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT) {
        cstrs.push_back("depth/stencil attachment read");
    }

    if (vals & VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT) {
        cstrs.push_back("depth/stencil attachment write");
    }

    if (vals & VK_ACCESS_TRANSFER_READ_BIT) {
        cstrs.push_back("transfer read");
    }

    if (vals & VK_ACCESS_TRANSFER_WRITE_BIT) {
        cstrs.push_back("transfer write");
    }

    if (vals & VK_ACCESS_HOST_READ_BIT) {
        cstrs.push_back("host read");
    }

    if (vals & VK_ACCESS_HOST_WRITE_BIT) {
        cstrs.push_back("host write");
    }

    if (vals & VK_ACCESS_MEMORY_READ_BIT) {
        cstrs.push_back("memory read");
    }

    if (vals & VK_ACCESS_MEMORY_WRITE_BIT) {
        cstrs.push_back("memory write");
    }

    if (vals & VK_ACCESS_NONE) {
        cstrs.push_back("none");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkBufferUsageFlagBits. Should be safe to static_cast between.
 */
enum class BufferUsageFlag {
    trnsfr_src = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    trnsfr_dst = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    unfrm_texel_buffer = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    strge_texel_buffer = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    unfrm_buffer = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    strge_buffer = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    index_buffer = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    vertex_buffer = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    indrct_buffer = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    shader_device_addrss = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
};

constexpr std::string buffer_usage_flag_str(BufferUsageFlag val)
{
    using enum BufferUsageFlag;

    switch(val) {
    case trnsfr_src:
        return "transfer src";
    case trnsfr_dst:
        return "transfer dst";
    case unfrm_texel_buffer:
        return "uniform texel buffer";
    case strge_texel_buffer:
        return "storage texel buffer";
    case unfrm_buffer:
        return "uniform buffer";
    case strge_buffer:
        return "storage buffer";
    case index_buffer:
        return "index buffer";
    case vertex_buffer:
        return "vertex buffer";
    case indrct_buffer:
        return "indirect buffer";
    case shader_device_addrss:
        return "shader device address";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string buffer_usage_flag_str(VkBufferUsageFlagBits val)
{
    return buffer_usage_flag_str(static_cast<BufferUsageFlag>(val));
}

using BufferUsageFlags = VkBufferUsageFlags;

constexpr std::vector<const char*> buffer_usage_flags_cstrs(VkBufferUsageFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_BUFFER_USAGE_TRANSFER_SRC_BIT) {
        cstrs.push_back("transfer src");
    }

    if (vals & VK_BUFFER_USAGE_TRANSFER_DST_BIT) {
        cstrs.push_back("transfer dst");
    }

    if (vals & VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT) {
        cstrs.push_back("uniform texel buffer");
    }

    if (vals & VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT) {
        cstrs.push_back("storage texel buffer");
    }

    if (vals & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT) {
        cstrs.push_back("uniform buffer");
    }

    if (vals & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT) {
        cstrs.push_back("storage buffer");
    }

    if (vals & VK_BUFFER_USAGE_INDEX_BUFFER_BIT) {
        cstrs.push_back("index buffer");
    }

    if (vals & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
        cstrs.push_back("vertex buffer");
    }

    if (vals & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
        cstrs.push_back("indirect buffer");
    }

    if (vals & VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT) {
        cstrs.push_back("shader device address");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkBufferCreateFlagBits. Should be safe to static_cast between.
 */
enum class BufferCreateFlag {
    sparse_bndng = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    sparse_rsdncy = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    sparse_alsd = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    prtctd = VK_BUFFER_CREATE_PROTECTED_BIT,
    device_addrss_cptre_replay = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
};

constexpr std::string buffer_create_flag_str(BufferCreateFlag val)
{
    using enum BufferCreateFlag;

    switch(val) {
    case sparse_bndng:
        return "sparse binding";
    case sparse_rsdncy:
        return "sparse residency";
    case sparse_alsd:
        return "sparse aliased";
    case prtctd:
        return "protected";
    case device_addrss_cptre_replay:
        return "device address capture replay";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string buffer_create_flag_str(VkBufferCreateFlagBits val)
{
    return buffer_create_flag_str(static_cast<BufferCreateFlag>(val));
}

using BufferCreateFlags = VkBufferCreateFlags;

constexpr std::vector<const char*> buffer_create_flags_cstrs(VkBufferCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_BUFFER_CREATE_SPARSE_BINDING_BIT) {
        cstrs.push_back("sparse binding");
    }

    if (vals & VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT) {
        cstrs.push_back("sparse residency");
    }

    if (vals & VK_BUFFER_CREATE_SPARSE_ALIASED_BIT) {
        cstrs.push_back("sparse aliased");
    }

    if (vals & VK_BUFFER_CREATE_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    if (vals & VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) {
        cstrs.push_back("device address capture replay");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkShaderStageFlagBits. Should be safe to static_cast between.
 */
enum class ShaderStageFlag {
    vertex = VK_SHADER_STAGE_VERTEX_BIT,
    tsslltn_cntrl = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    tsslltn_evltn = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    gmtry = VK_SHADER_STAGE_GEOMETRY_BIT,
    frgmnt = VK_SHADER_STAGE_FRAGMENT_BIT,
    cmpte = VK_SHADER_STAGE_COMPUTE_BIT,
    all_grphcs = VK_SHADER_STAGE_ALL_GRAPHICS,
    all = VK_SHADER_STAGE_ALL,
};

constexpr std::string shader_stage_flag_str(ShaderStageFlag val)
{
    using enum ShaderStageFlag;

    switch(val) {
    case vertex:
        return "vertex";
    case tsslltn_cntrl:
        return "tessellation control";
    case tsslltn_evltn:
        return "tessellation evaluation";
    case gmtry:
        return "geometry";
    case frgmnt:
        return "fragment";
    case cmpte:
        return "compute";
    case all_grphcs:
        return "all graphics";
    case all:
        return "all";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string shader_stage_flag_str(VkShaderStageFlagBits val)
{
    return shader_stage_flag_str(static_cast<ShaderStageFlag>(val));
}

using ShaderStageFlags = VkShaderStageFlags;

constexpr std::vector<const char*> shader_stage_flags_cstrs(VkShaderStageFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SHADER_STAGE_VERTEX_BIT) {
        cstrs.push_back("vertex");
    }

    if (vals & VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT) {
        cstrs.push_back("tessellation control");
    }

    if (vals & VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT) {
        cstrs.push_back("tessellation evaluation");
    }

    if (vals & VK_SHADER_STAGE_GEOMETRY_BIT) {
        cstrs.push_back("geometry");
    }

    if (vals & VK_SHADER_STAGE_FRAGMENT_BIT) {
        cstrs.push_back("fragment");
    }

    if (vals & VK_SHADER_STAGE_COMPUTE_BIT) {
        cstrs.push_back("compute");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkImageUsageFlagBits. Should be safe to static_cast between.
 */
enum class ImageUsageFlag {
    trnsfr_src = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    trnsfr_dst = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    smpld = VK_IMAGE_USAGE_SAMPLED_BIT,
    strge = VK_IMAGE_USAGE_STORAGE_BIT,
    color_attchmt = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    depth_stncl_attchmt = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    trnsnt_attchmt = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    input_attchmt = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
};

constexpr std::string img_usage_flag_str(ImageUsageFlag val)
{
    using enum ImageUsageFlag;

    switch(val) {
    case trnsfr_src:
        return "transfer src";
    case trnsfr_dst:
        return "transfer dst";
    case smpld:
        return "sampled";
    case strge:
        return "storage";
    case color_attchmt:
        return "color attachment";
    case depth_stncl_attchmt:
        return "depth/stencil attachment";
    case trnsnt_attchmt:
        return "transient attachment";
    case input_attchmt:
        return "input attachment";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_usage_flag_str(VkImageUsageFlagBits val)
{
    return img_usage_flag_str(static_cast<ImageUsageFlag>(val));
}

using ImageUsageFlags = VkImageUsageFlags;

constexpr std::vector<const char*> img_usage_flags_cstrs(VkImageUsageFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
        cstrs.push_back("transfer src");
    }

    if (vals & VK_IMAGE_USAGE_TRANSFER_DST_BIT) {
        cstrs.push_back("transfer dst");
    }

    if (vals & VK_IMAGE_USAGE_SAMPLED_BIT) {
        cstrs.push_back("sampled");
    }

    if (vals & VK_IMAGE_USAGE_STORAGE_BIT) {
        cstrs.push_back("storage");
    }

    if (vals & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) {
        cstrs.push_back("color attachment");
    }

    if (vals & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
        cstrs.push_back("depth/stencil attachment");
    }

    if (vals & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT) {
        cstrs.push_back("transient attachment");
    }

    if (vals & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT) {
        cstrs.push_back("input attachment");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkImageCreateFlagBits. Should be safe to static_cast between.
 */
enum class ImageCreateFlag {
    sparse_bndng = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    sparse_rsdncy = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    sparse_alsd = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    mtble_format = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    cube_cmptbl = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    alias = VK_IMAGE_CREATE_ALIAS_BIT,
    split_instnc_bind_rgns = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    twod_array_cmptbl = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    block_texel_view_cmptbl = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    extndd_usage = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    prtctd = VK_IMAGE_CREATE_PROTECTED_BIT,
    dsjnt = VK_IMAGE_CREATE_DISJOINT_BIT,
};

constexpr std::string img_create_flag_str(ImageCreateFlag val)
{
    using enum ImageCreateFlag;

    switch(val) {
    case sparse_bndng:
        return "sparse binding";
    case sparse_rsdncy:
        return "sparse residency";
    case sparse_alsd:
        return "sparse aliased";
    case mtble_format:
        return "mutable format";
    case cube_cmptbl:
        return "cube compatible";
    case alias:
        return "alias";
    case split_instnc_bind_rgns:
        return "split instance bind regions";
    case twod_array_cmptbl:
        return "2D array compatible";
    case block_texel_view_cmptbl:
        return "block texel view compatible";
    case extndd_usage:
        return "extended usage";
    case prtctd:
        return "protected";
    case dsjnt:
        return "disjoint";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_create_flag_str(VkImageCreateFlagBits val)
{
    return img_create_flag_str(static_cast<ImageCreateFlag>(val));
}

using ImageCreateFlags = VkImageCreateFlags;

constexpr std::vector<const char*> img_create_flags_cstrs(VkImageCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) {
        cstrs.push_back("sparse binding");
    }

    if (vals & VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT) {
        cstrs.push_back("sparse residency");
    }

    if (vals & VK_IMAGE_CREATE_SPARSE_ALIASED_BIT) {
        cstrs.push_back("sparse aliased");
    }

    if (vals & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT) {
        cstrs.push_back("mutable format");
    }

    if (vals & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT) {
        cstrs.push_back("cube compatible");
    }

    if (vals & VK_IMAGE_CREATE_ALIAS_BIT) {
        cstrs.push_back("alias");
    }

    if (vals & VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT) {
        cstrs.push_back("split instance bind regions");
    }

    if (vals & VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT) {
        cstrs.push_back("2D array compatible");
    }

    if (vals & VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT) {
        cstrs.push_back("block texel view compatible");
    }

    if (vals & VK_IMAGE_CREATE_EXTENDED_USAGE_BIT) {
        cstrs.push_back("extended usage");
    }

    if (vals & VK_IMAGE_CREATE_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    if (vals & VK_IMAGE_CREATE_DISJOINT_BIT) {
        cstrs.push_back("disjoint");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPipelineCreateFlagBits. Should be safe to static_cast between.
 */
enum class PipelineCreateFlag {
    dsble_optmztn = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    allow_drvtvs = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    drvtve = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    view_index_from_device_index = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    dsptch_base = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
    fail_on_pplne_cmple_rqrd = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
    early_return_on_flre = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
};

constexpr std::string pplne_create_flag_str(PipelineCreateFlag val)
{
    using enum PipelineCreateFlag;

    switch(val) {
    case dsble_optmztn:
        return "disable optimization";
    case allow_drvtvs:
        return "allow derivatives";
    case drvtve:
        return "derivative";
    case view_index_from_device_index:
        return "view index from device index";
    case dsptch_base:
        return "dispatch base";
    case fail_on_pplne_cmple_rqrd:
        return "fail on pipeline compile required";
    case early_return_on_flre:
        return "early return on failure";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_create_flag_str(VkPipelineCreateFlagBits val)
{
    return pplne_create_flag_str(static_cast<PipelineCreateFlag>(val));
}

using PipelineCreateFlags = VkPipelineCreateFlags;

constexpr std::vector<const char*> pplne_create_flags_cstrs(VkPipelineCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT) {
        cstrs.push_back("disable optimization");
    }

    if (vals & VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT) {
        cstrs.push_back("allow derivatives");
    }

    if (vals & VK_PIPELINE_CREATE_DERIVATIVE_BIT) {
        cstrs.push_back("derivative");
    }

    if (vals & VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT) {
        cstrs.push_back("view index from device index");
    }

    if (vals & VK_PIPELINE_CREATE_DISPATCH_BASE_BIT) {
        cstrs.push_back("dispatch base");
    }

    if (vals & VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT) {
        cstrs.push_back("fail on pipeline compile required");
    }

    if (vals & VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT) {
        cstrs.push_back("early return on failure");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPipelineShaderStageCreateFlagBits. Should be safe to static_cast between.
 */
enum class PipelineShaderStageCreateFlag {
    allow_vryng_sbgrp_size = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
    rqre_full_sbgrps = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
};

constexpr std::string pplne_shader_stage_create_flag_str(PipelineShaderStageCreateFlag val)
{
    using enum PipelineShaderStageCreateFlag;

    switch(val) {
    case allow_vryng_sbgrp_size:
        return "allow varying subgroup size";
    case rqre_full_sbgrps:
        return "require full subgroups";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_shader_stage_create_flag_str(VkPipelineShaderStageCreateFlagBits val)
{
    return pplne_shader_stage_create_flag_str(static_cast<PipelineShaderStageCreateFlag>(val));
}

using PipelineShaderStageCreateFlags = VkPipelineShaderStageCreateFlags;

constexpr std::vector<const char*> pplne_shader_stage_create_flags_cstrs(VkPipelineShaderStageCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT) {
        cstrs.push_back("allow varying subgroup size");
    }

    if (vals & VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT) {
        cstrs.push_back("require full subgroups");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkColorComponentFlagBits. Should be safe to static_cast between.
 */
enum class ColorComponentFlag {
    r = VK_COLOR_COMPONENT_R_BIT,
    g = VK_COLOR_COMPONENT_G_BIT,
    b = VK_COLOR_COMPONENT_B_BIT,
    a = VK_COLOR_COMPONENT_A_BIT,
};

constexpr std::string color_cmpnnt_flag_str(ColorComponentFlag val)
{
    using enum ColorComponentFlag;

    switch(val) {
    case r:
        return "r";
    case g:
        return "g";
    case b:
        return "b";
    case a:
        return "a";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string color_cmpnnt_flag_str(VkColorComponentFlagBits val)
{
    return color_cmpnnt_flag_str(static_cast<ColorComponentFlag>(val));
}

using ColorComponentFlags = VkColorComponentFlags;

constexpr std::vector<const char*> color_cmpnnt_flags_cstrs(VkColorComponentFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COLOR_COMPONENT_R_BIT) {
        cstrs.push_back("r");
    }

    if (vals & VK_COLOR_COMPONENT_G_BIT) {
        cstrs.push_back("g");
    }

    if (vals & VK_COLOR_COMPONENT_B_BIT) {
        cstrs.push_back("b");
    }

    if (vals & VK_COLOR_COMPONENT_A_BIT) {
        cstrs.push_back("a");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkFenceCreateFlagBits. Should be safe to static_cast between.
 */
enum class FenceCreateFlag {
    sgnld = VK_FENCE_CREATE_SIGNALED_BIT,
};

constexpr std::string fence_create_flag_str(FenceCreateFlag val)
{
    using enum FenceCreateFlag;

    switch(val) {
    case sgnld:
        return "signaled";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string fence_create_flag_str(VkFenceCreateFlagBits val)
{
    return fence_create_flag_str(static_cast<FenceCreateFlag>(val));
}

using FenceCreateFlags = VkFenceCreateFlags;

constexpr std::vector<const char*> fence_create_flags_cstrs(VkFenceCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_FENCE_CREATE_SIGNALED_BIT) {
        cstrs.push_back("signaled");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkFormatFeatureFlagBits. Should be safe to static_cast between.
 */
enum class FormatFeatureFlag {
    smpld_img = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    strge_img = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    strge_img_atomic = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    unfrm_texel_buffer = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    strge_texel_buffer = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    strge_texel_buffer_atomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    vertex_buffer = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    color_attchmt = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    color_attchmt_blend = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    depth_stncl_attchmt = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    blit_src = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    blit_dst = VK_FORMAT_FEATURE_BLIT_DST_BIT,
    smpld_img_filter_linear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    trnsfr_src = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    trnsfr_dst = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    mdpnt_chroma_smpls = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    smpld_img_ycbcr_cnvrsn_linear_filter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    smpld_img_ycbcr_cnvrsn_sprte_rcnstrn_filter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    smpld_img_ycbcr_cnvrsn_chroma_rcnstrn_explct = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    smpld_img_ycbcr_cnvrsn_chroma_rcnstrn_explct_frcble = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    dsjnt = VK_FORMAT_FEATURE_DISJOINT_BIT,
    cstd_chroma_smpls = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    smpld_img_filter_minmax = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
};

constexpr std::string format_ftre_flag_str(FormatFeatureFlag val)
{
    using enum FormatFeatureFlag;

    switch(val) {
    case smpld_img:
        return "sampled image";
    case strge_img:
        return "storage image";
    case strge_img_atomic:
        return "storage image atomic";
    case unfrm_texel_buffer:
        return "uniform texel buffer";
    case strge_texel_buffer:
        return "storage texel buffer";
    case strge_texel_buffer_atomic:
        return "storage texel buffer atomic";
    case vertex_buffer:
        return "vertex buffer";
    case color_attchmt:
        return "color attachment";
    case color_attchmt_blend:
        return "color attachment blend";
    case depth_stncl_attchmt:
        return "depth/stencil attachment";
    case blit_src:
        return "blit src";
    case blit_dst:
        return "blit dst";
    case smpld_img_filter_linear:
        return "sampled image filter linear";
    case trnsfr_src:
        return "transfer src";
    case trnsfr_dst:
        return "transfer dst";
    case mdpnt_chroma_smpls:
        return "midpoint chroma samples";
    case smpld_img_ycbcr_cnvrsn_linear_filter:
        return "sampled image ycbcr conversion linear filter";
    case smpld_img_ycbcr_cnvrsn_sprte_rcnstrn_filter:
        return "sampled image ycbcr conversion separate reconstruction filter";
    case smpld_img_ycbcr_cnvrsn_chroma_rcnstrn_explct:
        return "sampled image ycbcr conversion chroma reconstruction explicit";
    case smpld_img_ycbcr_cnvrsn_chroma_rcnstrn_explct_frcble:
        return "sampled image ycbcr conversion chroma reconstruction explicit forceable";
    case dsjnt:
        return "disjoint";
    case cstd_chroma_smpls:
        return "cosited chroma samples";
    case smpld_img_filter_minmax:
        return "sampled image filter minmax";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string format_ftre_flag_str(VkFormatFeatureFlagBits val)
{
    return format_ftre_flag_str(static_cast<FormatFeatureFlag>(val));
}

using FormatFeatureFlags = VkFormatFeatureFlags;

constexpr std::vector<const char*> format_ftre_flags_cstrs(VkFormatFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) {
        cstrs.push_back("sampled image");
    }

    if (vals & VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT) {
        cstrs.push_back("storage image");
    }

    if (vals & VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT) {
        cstrs.push_back("storage image atomic");
    }

    if (vals & VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT) {
        cstrs.push_back("uniform texel buffer");
    }

    if (vals & VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT) {
        cstrs.push_back("storage texel buffer");
    }

    if (vals & VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT) {
        cstrs.push_back("storage texel buffer atomic");
    }

    if (vals & VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT) {
        cstrs.push_back("vertex buffer");
    }

    if (vals & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) {
        cstrs.push_back("color attachment");
    }

    if (vals & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT) {
        cstrs.push_back("color attachment blend");
    }

    if (vals & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
        cstrs.push_back("depth/stencil attachment");
    }

    if (vals & VK_FORMAT_FEATURE_BLIT_SRC_BIT) {
        cstrs.push_back("blit src");
    }

    if (vals & VK_FORMAT_FEATURE_BLIT_DST_BIT) {
        cstrs.push_back("blit dst");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT) {
        cstrs.push_back("sampled image filter linear");
    }

    if (vals & VK_FORMAT_FEATURE_TRANSFER_SRC_BIT) {
        cstrs.push_back("transfer src");
    }

    if (vals & VK_FORMAT_FEATURE_TRANSFER_DST_BIT) {
        cstrs.push_back("transfer dst");
    }

    if (vals & VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT) {
        cstrs.push_back("midpoint chroma samples");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT) {
        cstrs.push_back("sampled image ycbcr conversion linear filter");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT) {
        cstrs.push_back("sampled image ycbcr conversion separate reconstruction filter");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT) {
        cstrs.push_back("sampled image ycbcr conversion chroma reconstruction explicit");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT) {
        cstrs.push_back("sampled image ycbcr conversion chroma reconstruction explicit forceable");
    }

    if (vals & VK_FORMAT_FEATURE_DISJOINT_BIT) {
        cstrs.push_back("disjoint");
    }

    if (vals & VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT) {
        cstrs.push_back("cosited chroma samples");
    }

    if (vals & VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT) {
        cstrs.push_back("sampled image filter minmax");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkQueryControlFlagBits. Should be safe to static_cast between.
 */
enum class QueryControlFlag {
    prcse = VK_QUERY_CONTROL_PRECISE_BIT,
};

constexpr std::string query_cntrl_flag_str(QueryControlFlag val)
{
    using enum QueryControlFlag;

    switch(val) {
    case prcse:
        return "precise";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string query_cntrl_flag_str(VkQueryControlFlagBits val)
{
    return query_cntrl_flag_str(static_cast<QueryControlFlag>(val));
}

using QueryControlFlags = VkQueryControlFlags;

constexpr std::vector<const char*> query_cntrl_flags_cstrs(VkQueryControlFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_QUERY_CONTROL_PRECISE_BIT) {
        cstrs.push_back("precise");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCommandBufferUsageFlagBits. Should be safe to static_cast between.
 */
enum class CommandBufferUsageFlag {
    one_time_submit = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    render_pass_cntne = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    smltns_use = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
};

constexpr std::string cmmnd_buffer_usage_flag_str(CommandBufferUsageFlag val)
{
    using enum CommandBufferUsageFlag;

    switch(val) {
    case one_time_submit:
        return "1 time submit";
    case render_pass_cntne:
        return "render pass continue";
    case smltns_use:
        return "simultaneous use";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmmnd_buffer_usage_flag_str(VkCommandBufferUsageFlagBits val)
{
    return cmmnd_buffer_usage_flag_str(static_cast<CommandBufferUsageFlag>(val));
}

using CommandBufferUsageFlags = VkCommandBufferUsageFlags;

constexpr std::vector<const char*> cmmnd_buffer_usage_flags_cstrs(VkCommandBufferUsageFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT) {
        cstrs.push_back("1 time submit");
    }

    if (vals & VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT) {
        cstrs.push_back("render pass continue");
    }

    if (vals & VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT) {
        cstrs.push_back("simultaneous use");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkQueryPipelineStatisticFlagBits. Should be safe to static_cast between.
 */
enum class QueryPipelineStatisticFlag {
    input_assmbly_vrtcs = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    input_assmbly_prmtvs = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    vertex_shader_invctns = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    gmtry_shader_invctns = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    gmtry_shader_prmtvs = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    clppng_invctns = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    clppng_prmtvs = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    frgmnt_shader_invctns = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    tsslltn_cntrl_shader_ptchs = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    tsslltn_evltn_shader_invctns = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    cmpte_shader_invctns = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
};

constexpr std::string query_pplne_sttstc_flag_str(QueryPipelineStatisticFlag val)
{
    using enum QueryPipelineStatisticFlag;

    switch(val) {
    case input_assmbly_vrtcs:
        return "input assembly vertices";
    case input_assmbly_prmtvs:
        return "input assembly primitives";
    case vertex_shader_invctns:
        return "vertex shader invocations";
    case gmtry_shader_invctns:
        return "geometry shader invocations";
    case gmtry_shader_prmtvs:
        return "geometry shader primitives";
    case clppng_invctns:
        return "clipping invocations";
    case clppng_prmtvs:
        return "clipping primitives";
    case frgmnt_shader_invctns:
        return "fragment shader invocations";
    case tsslltn_cntrl_shader_ptchs:
        return "tessellation control shader patches";
    case tsslltn_evltn_shader_invctns:
        return "tessellation evaluation shader invocations";
    case cmpte_shader_invctns:
        return "compute shader invocations";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string query_pplne_sttstc_flag_str(VkQueryPipelineStatisticFlagBits val)
{
    return query_pplne_sttstc_flag_str(static_cast<QueryPipelineStatisticFlag>(val));
}

using QueryPipelineStatisticFlags = VkQueryPipelineStatisticFlags;

constexpr std::vector<const char*> query_pplne_sttstc_flags_cstrs(VkQueryPipelineStatisticFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT) {
        cstrs.push_back("input assembly vertices");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT) {
        cstrs.push_back("input assembly primitives");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT) {
        cstrs.push_back("vertex shader invocations");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT) {
        cstrs.push_back("geometry shader invocations");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT) {
        cstrs.push_back("geometry shader primitives");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT) {
        cstrs.push_back("clipping invocations");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT) {
        cstrs.push_back("clipping primitives");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT) {
        cstrs.push_back("fragment shader invocations");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT) {
        cstrs.push_back("tessellation control shader patches");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT) {
        cstrs.push_back("tessellation evaluation shader invocations");
    }

    if (vals & VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT) {
        cstrs.push_back("compute shader invocations");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkImageAspectFlagBits. Should be safe to static_cast between.
 */
enum class ImageAspectFlag {
    color = VK_IMAGE_ASPECT_COLOR_BIT,
    depth = VK_IMAGE_ASPECT_DEPTH_BIT,
    stncl = VK_IMAGE_ASPECT_STENCIL_BIT,
    mtdta = VK_IMAGE_ASPECT_METADATA_BIT,
    plane_0 = VK_IMAGE_ASPECT_PLANE_0_BIT,
    plane_1 = VK_IMAGE_ASPECT_PLANE_1_BIT,
    plane_2 = VK_IMAGE_ASPECT_PLANE_2_BIT,
    none = VK_IMAGE_ASPECT_NONE,
};

constexpr std::string img_aspect_flag_str(ImageAspectFlag val)
{
    using enum ImageAspectFlag;

    switch(val) {
    case color:
        return "color";
    case depth:
        return "depth";
    case stncl:
        return "stencil";
    case mtdta:
        return "metadata";
    case plane_0:
        return "plane 0";
    case plane_1:
        return "plane 1";
    case plane_2:
        return "plane 2";
    case none:
        return "none";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string img_aspect_flag_str(VkImageAspectFlagBits val)
{
    return img_aspect_flag_str(static_cast<ImageAspectFlag>(val));
}

using ImageAspectFlags = VkImageAspectFlags;

constexpr std::vector<const char*> img_aspect_flags_cstrs(VkImageAspectFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_IMAGE_ASPECT_COLOR_BIT) {
        cstrs.push_back("color");
    }

    if (vals & VK_IMAGE_ASPECT_DEPTH_BIT) {
        cstrs.push_back("depth");
    }

    if (vals & VK_IMAGE_ASPECT_STENCIL_BIT) {
        cstrs.push_back("stencil");
    }

    if (vals & VK_IMAGE_ASPECT_METADATA_BIT) {
        cstrs.push_back("metadata");
    }

    if (vals & VK_IMAGE_ASPECT_PLANE_0_BIT) {
        cstrs.push_back("plane 0");
    }

    if (vals & VK_IMAGE_ASPECT_PLANE_1_BIT) {
        cstrs.push_back("plane 1");
    }

    if (vals & VK_IMAGE_ASPECT_PLANE_2_BIT) {
        cstrs.push_back("plane 2");
    }

    if (vals & VK_IMAGE_ASPECT_NONE) {
        cstrs.push_back("none");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSparseImageFormatFlagBits. Should be safe to static_cast between.
 */
enum class SparseImageFormatFlag {
    single_mptl = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    algnd_mip_size = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    nnstnd_block_size = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
};

constexpr std::string sparse_img_format_flag_str(SparseImageFormatFlag val)
{
    using enum SparseImageFormatFlag;

    switch(val) {
    case single_mptl:
        return "single miptail";
    case algnd_mip_size:
        return "aligned mip size";
    case nnstnd_block_size:
        return "nonstandard block size";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string sparse_img_format_flag_str(VkSparseImageFormatFlagBits val)
{
    return sparse_img_format_flag_str(static_cast<SparseImageFormatFlag>(val));
}

using SparseImageFormatFlags = VkSparseImageFormatFlags;

constexpr std::vector<const char*> sparse_img_format_flags_cstrs(VkSparseImageFormatFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT) {
        cstrs.push_back("single miptail");
    }

    if (vals & VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT) {
        cstrs.push_back("aligned mip size");
    }

    if (vals & VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT) {
        cstrs.push_back("nonstandard block size");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSparseMemoryBindFlagBits. Should be safe to static_cast between.
 */
enum class SparseMemoryBindFlag {
    mtdta = VK_SPARSE_MEMORY_BIND_METADATA_BIT,
};

constexpr std::string sparse_memory_bind_flag_str(SparseMemoryBindFlag val)
{
    using enum SparseMemoryBindFlag;

    switch(val) {
    case mtdta:
        return "metadata";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string sparse_memory_bind_flag_str(VkSparseMemoryBindFlagBits val)
{
    return sparse_memory_bind_flag_str(static_cast<SparseMemoryBindFlag>(val));
}

using SparseMemoryBindFlags = VkSparseMemoryBindFlags;

constexpr std::vector<const char*> sparse_memory_bind_flags_cstrs(VkSparseMemoryBindFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SPARSE_MEMORY_BIND_METADATA_BIT) {
        cstrs.push_back("metadata");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPipelineStageFlagBits. Should be safe to static_cast between.
 */
enum class PipelineStageFlag {
    top_of_pipe = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    draw_indrct = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    vertex_input = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    vertex_shader = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    tsslltn_cntrl_shader = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    tsslltn_evltn_shader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    gmtry_shader = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    frgmnt_shader = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    early_frgmnt_tests = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    late_frgmnt_tests = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    color_attchmt_output = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    cmpte_shader = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    trnsfr = VK_PIPELINE_STAGE_TRANSFER_BIT,
    bottom_of_pipe = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    host = VK_PIPELINE_STAGE_HOST_BIT,
    all_grphcs = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    all_cmmnds = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    none = VK_PIPELINE_STAGE_NONE,
};

constexpr std::string pplne_stage_flag_str(PipelineStageFlag val)
{
    using enum PipelineStageFlag;

    switch(val) {
    case top_of_pipe:
        return "top of pipe";
    case draw_indrct:
        return "draw indirect";
    case vertex_input:
        return "vertex input";
    case vertex_shader:
        return "vertex shader";
    case tsslltn_cntrl_shader:
        return "tessellation control shader";
    case tsslltn_evltn_shader:
        return "tessellation evaluation shader";
    case gmtry_shader:
        return "geometry shader";
    case frgmnt_shader:
        return "fragment shader";
    case early_frgmnt_tests:
        return "early fragment tests";
    case late_frgmnt_tests:
        return "late fragment tests";
    case color_attchmt_output:
        return "color attachment output";
    case cmpte_shader:
        return "compute shader";
    case trnsfr:
        return "transfer";
    case bottom_of_pipe:
        return "bottom of pipe";
    case host:
        return "host";
    case all_grphcs:
        return "all graphics";
    case all_cmmnds:
        return "all commands";
    case none:
        return "none";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_stage_flag_str(VkPipelineStageFlagBits val)
{
    return pplne_stage_flag_str(static_cast<PipelineStageFlag>(val));
}

using PipelineStageFlags = VkPipelineStageFlags;

constexpr std::vector<const char*> pplne_stage_flags_cstrs(VkPipelineStageFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT) {
        cstrs.push_back("top of pipe");
    }

    if (vals & VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT) {
        cstrs.push_back("draw indirect");
    }

    if (vals & VK_PIPELINE_STAGE_VERTEX_INPUT_BIT) {
        cstrs.push_back("vertex input");
    }

    if (vals & VK_PIPELINE_STAGE_VERTEX_SHADER_BIT) {
        cstrs.push_back("vertex shader");
    }

    if (vals & VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT) {
        cstrs.push_back("tessellation control shader");
    }

    if (vals & VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT) {
        cstrs.push_back("tessellation evaluation shader");
    }

    if (vals & VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT) {
        cstrs.push_back("geometry shader");
    }

    if (vals & VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT) {
        cstrs.push_back("fragment shader");
    }

    if (vals & VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT) {
        cstrs.push_back("early fragment tests");
    }

    if (vals & VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT) {
        cstrs.push_back("late fragment tests");
    }

    if (vals & VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT) {
        cstrs.push_back("color attachment output");
    }

    if (vals & VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT) {
        cstrs.push_back("compute shader");
    }

    if (vals & VK_PIPELINE_STAGE_TRANSFER_BIT) {
        cstrs.push_back("transfer");
    }

    if (vals & VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT) {
        cstrs.push_back("bottom of pipe");
    }

    if (vals & VK_PIPELINE_STAGE_HOST_BIT) {
        cstrs.push_back("host");
    }

    if (vals & VK_PIPELINE_STAGE_NONE) {
        cstrs.push_back("none");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCommandPoolCreateFlagBits. Should be safe to static_cast between.
 */
enum class CommandPoolCreateFlag {
    trnsnt = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    reset_cmmnd_buffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    prtctd = VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
};

constexpr std::string cmmnd_pool_create_flag_str(CommandPoolCreateFlag val)
{
    using enum CommandPoolCreateFlag;

    switch(val) {
    case trnsnt:
        return "transient";
    case reset_cmmnd_buffer:
        return "reset command buffer";
    case prtctd:
        return "protected";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmmnd_pool_create_flag_str(VkCommandPoolCreateFlagBits val)
{
    return cmmnd_pool_create_flag_str(static_cast<CommandPoolCreateFlag>(val));
}

using CommandPoolCreateFlags = VkCommandPoolCreateFlags;

constexpr std::vector<const char*> cmmnd_pool_create_flags_cstrs(VkCommandPoolCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COMMAND_POOL_CREATE_TRANSIENT_BIT) {
        cstrs.push_back("transient");
    }

    if (vals & VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT) {
        cstrs.push_back("reset command buffer");
    }

    if (vals & VK_COMMAND_POOL_CREATE_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCommandPoolResetFlagBits. Should be safe to static_cast between.
 */
enum class CommandPoolResetFlag {
    rlse_rsrcs = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
};

constexpr std::string cmmnd_pool_reset_flag_str(CommandPoolResetFlag val)
{
    using enum CommandPoolResetFlag;

    switch(val) {
    case rlse_rsrcs:
        return "release resources";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmmnd_pool_reset_flag_str(VkCommandPoolResetFlagBits val)
{
    return cmmnd_pool_reset_flag_str(static_cast<CommandPoolResetFlag>(val));
}

using CommandPoolResetFlags = VkCommandPoolResetFlags;

constexpr std::vector<const char*> cmmnd_pool_reset_flags_cstrs(VkCommandPoolResetFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT) {
        cstrs.push_back("release resources");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCommandBufferResetFlagBits. Should be safe to static_cast between.
 */
enum class CommandBufferResetFlag {
    rlse_rsrcs = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
};

constexpr std::string cmmnd_buffer_reset_flag_str(CommandBufferResetFlag val)
{
    using enum CommandBufferResetFlag;

    switch(val) {
    case rlse_rsrcs:
        return "release resources";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmmnd_buffer_reset_flag_str(VkCommandBufferResetFlagBits val)
{
    return cmmnd_buffer_reset_flag_str(static_cast<CommandBufferResetFlag>(val));
}

using CommandBufferResetFlags = VkCommandBufferResetFlags;

constexpr std::vector<const char*> cmmnd_buffer_reset_flags_cstrs(VkCommandBufferResetFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT) {
        cstrs.push_back("release resources");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSampleCountFlagBits. Should be safe to static_cast between.
 */
enum class SampleCountFlag {
    one = VK_SAMPLE_COUNT_1_BIT,
    two = VK_SAMPLE_COUNT_2_BIT,
    four = VK_SAMPLE_COUNT_4_BIT,
    eight = VK_SAMPLE_COUNT_8_BIT,
    sxtn = VK_SAMPLE_COUNT_16_BIT,
    thrtytw = VK_SAMPLE_COUNT_32_BIT,
    sxtyfr = VK_SAMPLE_COUNT_64_BIT,
};

constexpr std::string sample_count_flag_str(SampleCountFlag val)
{
    using enum SampleCountFlag;

    switch(val) {
    case one:
        return "1";
    case two:
        return "2";
    case four:
        return "4";
    case eight:
        return "8";
    case sxtn:
        return "16";
    case thrtytw:
        return "32";
    case sxtyfr:
        return "64";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string sample_count_flag_str(VkSampleCountFlagBits val)
{
    return sample_count_flag_str(static_cast<SampleCountFlag>(val));
}

using SampleCountFlags = VkSampleCountFlags;

constexpr std::vector<const char*> sample_count_flags_cstrs(VkSampleCountFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SAMPLE_COUNT_1_BIT) {
        cstrs.push_back("1");
    }

    if (vals & VK_SAMPLE_COUNT_2_BIT) {
        cstrs.push_back("2");
    }

    if (vals & VK_SAMPLE_COUNT_4_BIT) {
        cstrs.push_back("4");
    }

    if (vals & VK_SAMPLE_COUNT_8_BIT) {
        cstrs.push_back("8");
    }

    if (vals & VK_SAMPLE_COUNT_16_BIT) {
        cstrs.push_back("16");
    }

    if (vals & VK_SAMPLE_COUNT_32_BIT) {
        cstrs.push_back("32");
    }

    if (vals & VK_SAMPLE_COUNT_64_BIT) {
        cstrs.push_back("64");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkAttachmentDescriptionFlagBits. Should be safe to static_cast between.
 */
enum class AttachmentDescriptionFlag {
    may_alias = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
};

constexpr std::string attchmt_dscrptn_flag_str(AttachmentDescriptionFlag val)
{
    using enum AttachmentDescriptionFlag;

    switch(val) {
    case may_alias:
        return "may alias";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string attchmt_dscrptn_flag_str(VkAttachmentDescriptionFlagBits val)
{
    return attchmt_dscrptn_flag_str(static_cast<AttachmentDescriptionFlag>(val));
}

using AttachmentDescriptionFlags = VkAttachmentDescriptionFlags;

constexpr std::vector<const char*> attchmt_dscrptn_flags_cstrs(VkAttachmentDescriptionFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT) {
        cstrs.push_back("may alias");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkStencilFaceFlagBits. Should be safe to static_cast between.
 */
enum class StencilFaceFlag {
    front = VK_STENCIL_FACE_FRONT_BIT,
    back = VK_STENCIL_FACE_BACK_BIT,
    front_and_back = VK_STENCIL_FACE_FRONT_AND_BACK,
};

constexpr std::string stncl_face_flag_str(StencilFaceFlag val)
{
    using enum StencilFaceFlag;

    switch(val) {
    case front:
        return "front";
    case back:
        return "back";
    case front_and_back:
        return "front and back";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string stncl_face_flag_str(VkStencilFaceFlagBits val)
{
    return stncl_face_flag_str(static_cast<StencilFaceFlag>(val));
}

using StencilFaceFlags = VkStencilFaceFlags;

constexpr std::vector<const char*> stncl_face_flags_cstrs(VkStencilFaceFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_STENCIL_FACE_FRONT_BIT) {
        cstrs.push_back("front");
    }

    if (vals & VK_STENCIL_FACE_BACK_BIT) {
        cstrs.push_back("back");
    }

    if (vals & VK_STENCIL_FACE_FRONT_AND_BACK) {
        cstrs.push_back("front and back");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDescriptorPoolCreateFlagBits. Should be safe to static_cast between.
 */
enum class DescriptorPoolCreateFlag {
    free_dscrpt_set = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    update_after_bind = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
};

constexpr std::string dscrpt_pool_create_flag_str(DescriptorPoolCreateFlag val)
{
    using enum DescriptorPoolCreateFlag;

    switch(val) {
    case free_dscrpt_set:
        return "free descriptor set";
    case update_after_bind:
        return "update after bind";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dscrpt_pool_create_flag_str(VkDescriptorPoolCreateFlagBits val)
{
    return dscrpt_pool_create_flag_str(static_cast<DescriptorPoolCreateFlag>(val));
}

using DescriptorPoolCreateFlags = VkDescriptorPoolCreateFlags;

constexpr std::vector<const char*> dscrpt_pool_create_flags_cstrs(VkDescriptorPoolCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT) {
        cstrs.push_back("free descriptor set");
    }

    if (vals & VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT) {
        cstrs.push_back("update after bind");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDependencyFlagBits. Should be safe to static_cast between.
 */
enum class DependencyFlag {
    by_region = VK_DEPENDENCY_BY_REGION_BIT,
    device_group = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    view_local = VK_DEPENDENCY_VIEW_LOCAL_BIT,
};

constexpr std::string dpndncy_flag_str(DependencyFlag val)
{
    using enum DependencyFlag;

    switch(val) {
    case by_region:
        return "by region";
    case device_group:
        return "device group";
    case view_local:
        return "view local";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dpndncy_flag_str(VkDependencyFlagBits val)
{
    return dpndncy_flag_str(static_cast<DependencyFlag>(val));
}

using DependencyFlags = VkDependencyFlags;

constexpr std::vector<const char*> dpndncy_flags_cstrs(VkDependencyFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DEPENDENCY_BY_REGION_BIT) {
        cstrs.push_back("by region");
    }

    if (vals & VK_DEPENDENCY_DEVICE_GROUP_BIT) {
        cstrs.push_back("device group");
    }

    if (vals & VK_DEPENDENCY_VIEW_LOCAL_BIT) {
        cstrs.push_back("view local");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSemaphoreWaitFlagBits. Should be safe to static_cast between.
 */
enum class SemaphoreWaitFlag {
    any = VK_SEMAPHORE_WAIT_ANY_BIT,
};

constexpr std::string smphre_wait_flag_str(SemaphoreWaitFlag val)
{
    using enum SemaphoreWaitFlag;

    switch(val) {
    case any:
        return "any";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smphre_wait_flag_str(VkSemaphoreWaitFlagBits val)
{
    return smphre_wait_flag_str(static_cast<SemaphoreWaitFlag>(val));
}

using SemaphoreWaitFlags = VkSemaphoreWaitFlags;

constexpr std::vector<const char*> smphre_wait_flags_cstrs(VkSemaphoreWaitFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SEMAPHORE_WAIT_ANY_BIT) {
        cstrs.push_back("any");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDisplayPlaneAlphaFlagBitsKHR. Should be safe to static_cast between.
 */
enum class DisplayPlaneAlphaFlag {
    opaque = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    global = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    per_pixel = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    per_pixel_prmltpd = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
};

constexpr std::string dsply_plane_alpha_flag_str(DisplayPlaneAlphaFlag val)
{
    using enum DisplayPlaneAlphaFlag;

    switch(val) {
    case opaque:
        return "opaque";
    case global:
        return "global";
    case per_pixel:
        return "per pixel";
    case per_pixel_prmltpd:
        return "per pixel premultiplied";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dsply_plane_alpha_flag_str(VkDisplayPlaneAlphaFlagBitsKHR val)
{
    return dsply_plane_alpha_flag_str(static_cast<DisplayPlaneAlphaFlag>(val));
}

using DisplayPlaneAlphaFlags = VkDisplayPlaneAlphaFlagsKHR;

constexpr std::vector<const char*> dsply_plane_alpha_flags_cstrs(VkDisplayPlaneAlphaFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR) {
        cstrs.push_back("opaque");
    }

    if (vals & VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR) {
        cstrs.push_back("global");
    }

    if (vals & VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR) {
        cstrs.push_back("per pixel");
    }

    if (vals & VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR) {
        cstrs.push_back("per pixel premultiplied");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkCompositeAlphaFlagBitsKHR. Should be safe to static_cast between.
 */
enum class CompositeAlphaFlag {
    opaque = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    pre_mltpld = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    post_mltpld = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    inhrt = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
};

constexpr std::string cmpste_alpha_flag_str(CompositeAlphaFlag val)
{
    using enum CompositeAlphaFlag;

    switch(val) {
    case opaque:
        return "opaque";
    case pre_mltpld:
        return "pre multiplied";
    case post_mltpld:
        return "post multiplied";
    case inhrt:
        return "inherit";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string cmpste_alpha_flag_str(VkCompositeAlphaFlagBitsKHR val)
{
    return cmpste_alpha_flag_str(static_cast<CompositeAlphaFlag>(val));
}

using CompositeAlphaFlags = VkCompositeAlphaFlagsKHR;

constexpr std::vector<const char*> cmpste_alpha_flags_cstrs(VkCompositeAlphaFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR) {
        cstrs.push_back("opaque");
    }

    if (vals & VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR) {
        cstrs.push_back("pre multiplied");
    }

    if (vals & VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR) {
        cstrs.push_back("post multiplied");
    }

    if (vals & VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR) {
        cstrs.push_back("inherit");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSurfaceTransformFlagBitsKHR. Should be safe to static_cast between.
 */
enum class SurfaceTransformFlag {
    idntty = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    rotate_90 = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    rotate_180 = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    rotate_270 = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    hrzntl_mirror = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    hrzntl_mirror_rotate_90 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    hrzntl_mirror_rotate_180 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    hrzntl_mirror_rotate_270 = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    inhrt = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
};

constexpr std::string srfce_trnsfr_flag_str(SurfaceTransformFlag val)
{
    using enum SurfaceTransformFlag;

    switch(val) {
    case idntty:
        return "identity";
    case rotate_90:
        return "rotate 90";
    case rotate_180:
        return "rotate 180";
    case rotate_270:
        return "rotate 270";
    case hrzntl_mirror:
        return "horizontal mirror";
    case hrzntl_mirror_rotate_90:
        return "horizontal mirror rotate 90";
    case hrzntl_mirror_rotate_180:
        return "horizontal mirror rotate 180";
    case hrzntl_mirror_rotate_270:
        return "horizontal mirror rotate 270";
    case inhrt:
        return "inherit";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string srfce_trnsfr_flag_str(VkSurfaceTransformFlagBitsKHR val)
{
    return srfce_trnsfr_flag_str(static_cast<SurfaceTransformFlag>(val));
}

using SurfaceTransformFlags = VkSurfaceTransformFlagsKHR;

constexpr std::vector<const char*> srfce_trnsfr_flags_cstrs(VkSurfaceTransformFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR) {
        cstrs.push_back("identity");
    }

    if (vals & VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR) {
        cstrs.push_back("rotate 90");
    }

    if (vals & VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR) {
        cstrs.push_back("rotate 180");
    }

    if (vals & VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR) {
        cstrs.push_back("rotate 270");
    }

    if (vals & VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR) {
        cstrs.push_back("horizontal mirror");
    }

    if (vals & VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR) {
        cstrs.push_back("horizontal mirror rotate 90");
    }

    if (vals & VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR) {
        cstrs.push_back("horizontal mirror rotate 180");
    }

    if (vals & VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR) {
        cstrs.push_back("horizontal mirror rotate 270");
    }

    if (vals & VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR) {
        cstrs.push_back("inherit");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSubgroupFeatureFlagBits. Should be safe to static_cast between.
 */
enum class SubgroupFeatureFlag {
    basic = VK_SUBGROUP_FEATURE_BASIC_BIT,
    vote = VK_SUBGROUP_FEATURE_VOTE_BIT,
    arthmt = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    ballot = VK_SUBGROUP_FEATURE_BALLOT_BIT,
    shffle = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    shffle_rltve = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    clstrd = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    quad = VK_SUBGROUP_FEATURE_QUAD_BIT,
};

constexpr std::string sbgrp_ftre_flag_str(SubgroupFeatureFlag val)
{
    using enum SubgroupFeatureFlag;

    switch(val) {
    case basic:
        return "basic";
    case vote:
        return "vote";
    case arthmt:
        return "arithmetic";
    case ballot:
        return "ballot";
    case shffle:
        return "shuffle";
    case shffle_rltve:
        return "shuffle relative";
    case clstrd:
        return "clustered";
    case quad:
        return "quad";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string sbgrp_ftre_flag_str(VkSubgroupFeatureFlagBits val)
{
    return sbgrp_ftre_flag_str(static_cast<SubgroupFeatureFlag>(val));
}

using SubgroupFeatureFlags = VkSubgroupFeatureFlags;

constexpr std::vector<const char*> sbgrp_ftre_flags_cstrs(VkSubgroupFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SUBGROUP_FEATURE_BASIC_BIT) {
        cstrs.push_back("basic");
    }

    if (vals & VK_SUBGROUP_FEATURE_VOTE_BIT) {
        cstrs.push_back("vote");
    }

    if (vals & VK_SUBGROUP_FEATURE_ARITHMETIC_BIT) {
        cstrs.push_back("arithmetic");
    }

    if (vals & VK_SUBGROUP_FEATURE_BALLOT_BIT) {
        cstrs.push_back("ballot");
    }

    if (vals & VK_SUBGROUP_FEATURE_SHUFFLE_BIT) {
        cstrs.push_back("shuffle");
    }

    if (vals & VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT) {
        cstrs.push_back("shuffle relative");
    }

    if (vals & VK_SUBGROUP_FEATURE_CLUSTERED_BIT) {
        cstrs.push_back("clustered");
    }

    if (vals & VK_SUBGROUP_FEATURE_QUAD_BIT) {
        cstrs.push_back("quad");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDescriptorSetLayoutCreateFlagBits. Should be safe to static_cast between.
 */
enum class DescriptorSetLayoutCreateFlag {
    update_after_bind_pool = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
};

constexpr std::string dscrpt_set_layout_create_flag_str(DescriptorSetLayoutCreateFlag val)
{
    using enum DescriptorSetLayoutCreateFlag;

    switch(val) {
    case update_after_bind_pool:
        return "update after bind pool";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dscrpt_set_layout_create_flag_str(VkDescriptorSetLayoutCreateFlagBits val)
{
    return dscrpt_set_layout_create_flag_str(static_cast<DescriptorSetLayoutCreateFlag>(val));
}

using DescriptorSetLayoutCreateFlags = VkDescriptorSetLayoutCreateFlags;

constexpr std::vector<const char*> dscrpt_set_layout_create_flags_cstrs(VkDescriptorSetLayoutCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT) {
        cstrs.push_back("update after bind pool");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalMemoryHandleTypeFlagBits. Should be safe to static_cast between.
 */
enum class ExternalMemoryHandleTypeFlag {
    opaque_fd = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    opaque_win32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    opaque_win32_kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    d3d11_txtre = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    d3d11_txtre_kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    d3d12_heap = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    d3d12_rsrce = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
};

constexpr std::string extrnl_memory_handle_type_flag_str(ExternalMemoryHandleTypeFlag val)
{
    using enum ExternalMemoryHandleTypeFlag;

    switch(val) {
    case opaque_fd:
        return "opaque fd";
    case opaque_win32:
        return "opaque win32";
    case opaque_win32_kmt:
        return "opaque win32 kmt";
    case d3d11_txtre:
        return "d3D11 texture";
    case d3d11_txtre_kmt:
        return "d3D11 texture kmt";
    case d3d12_heap:
        return "d3D12 heap";
    case d3d12_rsrce:
        return "d3D12 resource";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_memory_handle_type_flag_str(VkExternalMemoryHandleTypeFlagBits val)
{
    return extrnl_memory_handle_type_flag_str(static_cast<ExternalMemoryHandleTypeFlag>(val));
}

using ExternalMemoryHandleTypeFlags = VkExternalMemoryHandleTypeFlags;

constexpr std::vector<const char*> extrnl_memory_handle_type_flags_cstrs(VkExternalMemoryHandleTypeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT) {
        cstrs.push_back("opaque fd");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
        cstrs.push_back("opaque win32");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT) {
        cstrs.push_back("opaque win32 kmt");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT) {
        cstrs.push_back("d3D11 texture");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT) {
        cstrs.push_back("d3D11 texture kmt");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT) {
        cstrs.push_back("d3D12 heap");
    }

    if (vals & VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT) {
        cstrs.push_back("d3D12 resource");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalMemoryFeatureFlagBits. Should be safe to static_cast between.
 */
enum class ExternalMemoryFeatureFlag {
    ddctd_only = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    exprtbl = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    imprtbl = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
};

constexpr std::string extrnl_memory_ftre_flag_str(ExternalMemoryFeatureFlag val)
{
    using enum ExternalMemoryFeatureFlag;

    switch(val) {
    case ddctd_only:
        return "dedicated only";
    case exprtbl:
        return "exportable";
    case imprtbl:
        return "importable";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_memory_ftre_flag_str(VkExternalMemoryFeatureFlagBits val)
{
    return extrnl_memory_ftre_flag_str(static_cast<ExternalMemoryFeatureFlag>(val));
}

using ExternalMemoryFeatureFlags = VkExternalMemoryFeatureFlags;

constexpr std::vector<const char*> extrnl_memory_ftre_flags_cstrs(VkExternalMemoryFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT) {
        cstrs.push_back("dedicated only");
    }

    if (vals & VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT) {
        cstrs.push_back("exportable");
    }

    if (vals & VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT) {
        cstrs.push_back("importable");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalSemaphoreHandleTypeFlagBits. Should be safe to static_cast between.
 */
enum class ExternalSemaphoreHandleTypeFlag {
    opaque_fd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    opaque_win32 = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    opaque_win32_kmt = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    d3d12_fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    sync_fd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
};

constexpr std::string extrnl_smphre_handle_type_flag_str(ExternalSemaphoreHandleTypeFlag val)
{
    using enum ExternalSemaphoreHandleTypeFlag;

    switch(val) {
    case opaque_fd:
        return "opaque fd";
    case opaque_win32:
        return "opaque win32";
    case opaque_win32_kmt:
        return "opaque win32 kmt";
    case d3d12_fence:
        return "d3D12 fence";
    case sync_fd:
        return "sync fd";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_smphre_handle_type_flag_str(VkExternalSemaphoreHandleTypeFlagBits val)
{
    return extrnl_smphre_handle_type_flag_str(static_cast<ExternalSemaphoreHandleTypeFlag>(val));
}

using ExternalSemaphoreHandleTypeFlags = VkExternalSemaphoreHandleTypeFlags;

constexpr std::vector<const char*> extrnl_smphre_handle_type_flags_cstrs(VkExternalSemaphoreHandleTypeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT) {
        cstrs.push_back("opaque fd");
    }

    if (vals & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
        cstrs.push_back("opaque win32");
    }

    if (vals & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT) {
        cstrs.push_back("opaque win32 kmt");
    }

    if (vals & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT) {
        cstrs.push_back("d3D12 fence");
    }

    if (vals & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT) {
        cstrs.push_back("sync fd");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalSemaphoreFeatureFlagBits. Should be safe to static_cast between.
 */
enum class ExternalSemaphoreFeatureFlag {
    exprtbl = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    imprtbl = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
};

constexpr std::string extrnl_smphre_ftre_flag_str(ExternalSemaphoreFeatureFlag val)
{
    using enum ExternalSemaphoreFeatureFlag;

    switch(val) {
    case exprtbl:
        return "exportable";
    case imprtbl:
        return "importable";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_smphre_ftre_flag_str(VkExternalSemaphoreFeatureFlagBits val)
{
    return extrnl_smphre_ftre_flag_str(static_cast<ExternalSemaphoreFeatureFlag>(val));
}

using ExternalSemaphoreFeatureFlags = VkExternalSemaphoreFeatureFlags;

constexpr std::vector<const char*> extrnl_smphre_ftre_flags_cstrs(VkExternalSemaphoreFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) {
        cstrs.push_back("exportable");
    }

    if (vals & VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT) {
        cstrs.push_back("importable");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSemaphoreImportFlagBits. Should be safe to static_cast between.
 */
enum class SemaphoreImportFlag {
    tmprry = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
};

constexpr std::string smphre_import_flag_str(SemaphoreImportFlag val)
{
    using enum SemaphoreImportFlag;

    switch(val) {
    case tmprry:
        return "temporary";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string smphre_import_flag_str(VkSemaphoreImportFlagBits val)
{
    return smphre_import_flag_str(static_cast<SemaphoreImportFlag>(val));
}

using SemaphoreImportFlags = VkSemaphoreImportFlags;

constexpr std::vector<const char*> smphre_import_flags_cstrs(VkSemaphoreImportFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT) {
        cstrs.push_back("temporary");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalFenceHandleTypeFlagBits. Should be safe to static_cast between.
 */
enum class ExternalFenceHandleTypeFlag {
    opaque_fd = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    opaque_win32 = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    opaque_win32_kmt = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    sync_fd = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
};

constexpr std::string extrnl_fence_handle_type_flag_str(ExternalFenceHandleTypeFlag val)
{
    using enum ExternalFenceHandleTypeFlag;

    switch(val) {
    case opaque_fd:
        return "opaque fd";
    case opaque_win32:
        return "opaque win32";
    case opaque_win32_kmt:
        return "opaque win32 kmt";
    case sync_fd:
        return "sync fd";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_fence_handle_type_flag_str(VkExternalFenceHandleTypeFlagBits val)
{
    return extrnl_fence_handle_type_flag_str(static_cast<ExternalFenceHandleTypeFlag>(val));
}

using ExternalFenceHandleTypeFlags = VkExternalFenceHandleTypeFlags;

constexpr std::vector<const char*> extrnl_fence_handle_type_flags_cstrs(VkExternalFenceHandleTypeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT) {
        cstrs.push_back("opaque fd");
    }

    if (vals & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT) {
        cstrs.push_back("opaque win32");
    }

    if (vals & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT) {
        cstrs.push_back("opaque win32 kmt");
    }

    if (vals & VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT) {
        cstrs.push_back("sync fd");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkExternalFenceFeatureFlagBits. Should be safe to static_cast between.
 */
enum class ExternalFenceFeatureFlag {
    exprtbl = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    imprtbl = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
};

constexpr std::string extrnl_fence_ftre_flag_str(ExternalFenceFeatureFlag val)
{
    using enum ExternalFenceFeatureFlag;

    switch(val) {
    case exprtbl:
        return "exportable";
    case imprtbl:
        return "importable";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string extrnl_fence_ftre_flag_str(VkExternalFenceFeatureFlagBits val)
{
    return extrnl_fence_ftre_flag_str(static_cast<ExternalFenceFeatureFlag>(val));
}

using ExternalFenceFeatureFlags = VkExternalFenceFeatureFlags;

constexpr std::vector<const char*> extrnl_fence_ftre_flags_cstrs(VkExternalFenceFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT) {
        cstrs.push_back("exportable");
    }

    if (vals & VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT) {
        cstrs.push_back("importable");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkFenceImportFlagBits. Should be safe to static_cast between.
 */
enum class FenceImportFlag {
    tmprry = VK_FENCE_IMPORT_TEMPORARY_BIT,
};

constexpr std::string fence_import_flag_str(FenceImportFlag val)
{
    using enum FenceImportFlag;

    switch(val) {
    case tmprry:
        return "temporary";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string fence_import_flag_str(VkFenceImportFlagBits val)
{
    return fence_import_flag_str(static_cast<FenceImportFlag>(val));
}

using FenceImportFlags = VkFenceImportFlags;

constexpr std::vector<const char*> fence_import_flags_cstrs(VkFenceImportFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_FENCE_IMPORT_TEMPORARY_BIT) {
        cstrs.push_back("temporary");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPeerMemoryFeatureFlagBits. Should be safe to static_cast between.
 */
enum class PeerMemoryFeatureFlag {
    copy_src = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    copy_dst = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    gnrc_src = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    gnrc_dst = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
};

constexpr std::string peer_memory_ftre_flag_str(PeerMemoryFeatureFlag val)
{
    using enum PeerMemoryFeatureFlag;

    switch(val) {
    case copy_src:
        return "copy src";
    case copy_dst:
        return "copy dst";
    case gnrc_src:
        return "generic src";
    case gnrc_dst:
        return "generic dst";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string peer_memory_ftre_flag_str(VkPeerMemoryFeatureFlagBits val)
{
    return peer_memory_ftre_flag_str(static_cast<PeerMemoryFeatureFlag>(val));
}

using PeerMemoryFeatureFlags = VkPeerMemoryFeatureFlags;

constexpr std::vector<const char*> peer_memory_ftre_flags_cstrs(VkPeerMemoryFeatureFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT) {
        cstrs.push_back("copy src");
    }

    if (vals & VK_PEER_MEMORY_FEATURE_COPY_DST_BIT) {
        cstrs.push_back("copy dst");
    }

    if (vals & VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT) {
        cstrs.push_back("generic src");
    }

    if (vals & VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT) {
        cstrs.push_back("generic dst");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkMemoryAllocateFlagBits. Should be safe to static_cast between.
 */
enum class MemoryAllocateFlag {
    device_mask = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    device_addrss = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
    device_addrss_cptre_replay = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
};

constexpr std::string memory_allcte_flag_str(MemoryAllocateFlag val)
{
    using enum MemoryAllocateFlag;

    switch(val) {
    case device_mask:
        return "device mask";
    case device_addrss:
        return "device address";
    case device_addrss_cptre_replay:
        return "device address capture replay";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string memory_allcte_flag_str(VkMemoryAllocateFlagBits val)
{
    return memory_allcte_flag_str(static_cast<MemoryAllocateFlag>(val));
}

using MemoryAllocateFlags = VkMemoryAllocateFlags;

constexpr std::vector<const char*> memory_allcte_flags_cstrs(VkMemoryAllocateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT) {
        cstrs.push_back("device mask");
    }

    if (vals & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT) {
        cstrs.push_back("device address");
    }

    if (vals & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) {
        cstrs.push_back("device address capture replay");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDeviceGroupPresentModeFlagBitsKHR. Should be safe to static_cast between.
 */
enum class DeviceGroupPresentModeFlag {
    local = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    remote = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    sum = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    local_multi_device = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
};

constexpr std::string device_group_prsnt_mode_flag_str(DeviceGroupPresentModeFlag val)
{
    using enum DeviceGroupPresentModeFlag;

    switch(val) {
    case local:
        return "local";
    case remote:
        return "remote";
    case sum:
        return "sum";
    case local_multi_device:
        return "local multi device";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string device_group_prsnt_mode_flag_str(VkDeviceGroupPresentModeFlagBitsKHR val)
{
    return device_group_prsnt_mode_flag_str(static_cast<DeviceGroupPresentModeFlag>(val));
}

using DeviceGroupPresentModeFlags = VkDeviceGroupPresentModeFlagsKHR;

constexpr std::vector<const char*> device_group_prsnt_mode_flags_cstrs(VkDeviceGroupPresentModeFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR) {
        cstrs.push_back("local");
    }

    if (vals & VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR) {
        cstrs.push_back("remote");
    }

    if (vals & VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR) {
        cstrs.push_back("sum");
    }

    if (vals & VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR) {
        cstrs.push_back("local multi device");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkDescriptorBindingFlagBits. Should be safe to static_cast between.
 */
enum class DescriptorBindingFlag {
    update_after_bind = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
    update_unused_while_pndng = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
    prtlly_bound = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
    vrble_dscrpt_count = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
};

constexpr std::string dscrpt_bndng_flag_str(DescriptorBindingFlag val)
{
    using enum DescriptorBindingFlag;

    switch(val) {
    case update_after_bind:
        return "update after bind";
    case update_unused_while_pndng:
        return "update unused while pending";
    case prtlly_bound:
        return "partially bound";
    case vrble_dscrpt_count:
        return "variable descriptor count";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string dscrpt_bndng_flag_str(VkDescriptorBindingFlagBits val)
{
    return dscrpt_bndng_flag_str(static_cast<DescriptorBindingFlag>(val));
}

using DescriptorBindingFlags = VkDescriptorBindingFlags;

constexpr std::vector<const char*> dscrpt_bndng_flags_cstrs(VkDescriptorBindingFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT) {
        cstrs.push_back("update after bind");
    }

    if (vals & VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT) {
        cstrs.push_back("update unused while pending");
    }

    if (vals & VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT) {
        cstrs.push_back("partially bound");
    }

    if (vals & VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT) {
        cstrs.push_back("variable descriptor count");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkResolveModeFlagBits. Should be safe to static_cast between.
 */
enum class ResolveModeFlag {
    none = VK_RESOLVE_MODE_NONE,
    sample_zero = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
    avrge = VK_RESOLVE_MODE_AVERAGE_BIT,
    min = VK_RESOLVE_MODE_MIN_BIT,
    max = VK_RESOLVE_MODE_MAX_BIT,
};

constexpr std::string rslve_mode_flag_str(ResolveModeFlag val)
{
    using enum ResolveModeFlag;

    switch(val) {
    case none:
        return "none";
    case sample_zero:
        return "sample zero";
    case avrge:
        return "average";
    case min:
        return "min";
    case max:
        return "max";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string rslve_mode_flag_str(VkResolveModeFlagBits val)
{
    return rslve_mode_flag_str(static_cast<ResolveModeFlag>(val));
}

using ResolveModeFlags = VkResolveModeFlags;

constexpr std::vector<const char*> rslve_mode_flags_cstrs(VkResolveModeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_RESOLVE_MODE_NONE) {
        cstrs.push_back("none");
    }

    if (vals & VK_RESOLVE_MODE_SAMPLE_ZERO_BIT) {
        cstrs.push_back("sample zero");
    }

    if (vals & VK_RESOLVE_MODE_AVERAGE_BIT) {
        cstrs.push_back("average");
    }

    if (vals & VK_RESOLVE_MODE_MIN_BIT) {
        cstrs.push_back("min");
    }

    if (vals & VK_RESOLVE_MODE_MAX_BIT) {
        cstrs.push_back("max");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkGeometryInstanceFlagBitsKHR. Should be safe to static_cast between.
 */
enum class GeometryInstanceFlag {
    trngle_facing_cull_dsble = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
    trngle_flip_facing = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
    force_opaque = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
    force_no_opaque = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
};

constexpr std::string gmtry_instnc_flag_str(GeometryInstanceFlag val)
{
    using enum GeometryInstanceFlag;

    switch(val) {
    case trngle_facing_cull_dsble:
        return "triangle facing cull disable";
    case trngle_flip_facing:
        return "triangle flip facing";
    case force_opaque:
        return "force opaque";
    case force_no_opaque:
        return "force no opaque";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string gmtry_instnc_flag_str(VkGeometryInstanceFlagBitsKHR val)
{
    return gmtry_instnc_flag_str(static_cast<GeometryInstanceFlag>(val));
}

using GeometryInstanceFlags = VkGeometryInstanceFlagsKHR;

constexpr std::vector<const char*> gmtry_instnc_flags_cstrs(VkGeometryInstanceFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR) {
        cstrs.push_back("triangle facing cull disable");
    }

    if (vals & VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR) {
        cstrs.push_back("triangle flip facing");
    }

    if (vals & VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR) {
        cstrs.push_back("force opaque");
    }

    if (vals & VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR) {
        cstrs.push_back("force no opaque");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkGeometryFlagBitsKHR. Should be safe to static_cast between.
 */
enum class GeometryFlag {
    opaque = VK_GEOMETRY_OPAQUE_BIT_KHR,
    no_dplcte_any_hit_invctn = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
};

constexpr std::string gmtry_flag_str(GeometryFlag val)
{
    using enum GeometryFlag;

    switch(val) {
    case opaque:
        return "opaque";
    case no_dplcte_any_hit_invctn:
        return "no duplicate any hit invocation";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string gmtry_flag_str(VkGeometryFlagBitsKHR val)
{
    return gmtry_flag_str(static_cast<GeometryFlag>(val));
}

using GeometryFlags = VkGeometryFlagsKHR;

constexpr std::vector<const char*> gmtry_flags_cstrs(VkGeometryFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_GEOMETRY_OPAQUE_BIT_KHR) {
        cstrs.push_back("opaque");
    }

    if (vals & VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR) {
        cstrs.push_back("no duplicate any hit invocation");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkBuildAccelerationStructureFlagBitsKHR. Should be safe to static_cast between.
 */
enum class BuildAccelerationStructureFlag {
    allow_update = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
    allow_cmpctn = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
    prefer_fast_trace = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
    prefer_fast_build = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
    low_memory = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
};

constexpr std::string build_acclrtn_strctr_flag_str(BuildAccelerationStructureFlag val)
{
    using enum BuildAccelerationStructureFlag;

    switch(val) {
    case allow_update:
        return "allow update";
    case allow_cmpctn:
        return "allow compaction";
    case prefer_fast_trace:
        return "prefer fast trace";
    case prefer_fast_build:
        return "prefer fast build";
    case low_memory:
        return "low memory";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string build_acclrtn_strctr_flag_str(VkBuildAccelerationStructureFlagBitsKHR val)
{
    return build_acclrtn_strctr_flag_str(static_cast<BuildAccelerationStructureFlag>(val));
}

using BuildAccelerationStructureFlags = VkBuildAccelerationStructureFlagsKHR;

constexpr std::vector<const char*> build_acclrtn_strctr_flags_cstrs(VkBuildAccelerationStructureFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR) {
        cstrs.push_back("allow update");
    }

    if (vals & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR) {
        cstrs.push_back("allow compaction");
    }

    if (vals & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR) {
        cstrs.push_back("prefer fast trace");
    }

    if (vals & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR) {
        cstrs.push_back("prefer fast build");
    }

    if (vals & VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR) {
        cstrs.push_back("low memory");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkAccelerationStructureCreateFlagBitsKHR. Should be safe to static_cast between.
 */
enum class AccelerationStructureCreateFlag {
    device_addrss_cptre_replay = VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
};

constexpr std::string acclrtn_strctr_create_flag_str(AccelerationStructureCreateFlag val)
{
    using enum AccelerationStructureCreateFlag;

    switch(val) {
    case device_addrss_cptre_replay:
        return "device address capture replay";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string acclrtn_strctr_create_flag_str(VkAccelerationStructureCreateFlagBitsKHR val)
{
    return acclrtn_strctr_create_flag_str(static_cast<AccelerationStructureCreateFlag>(val));
}

using AccelerationStructureCreateFlags = VkAccelerationStructureCreateFlagsKHR;

constexpr std::vector<const char*> acclrtn_strctr_create_flags_cstrs(VkAccelerationStructureCreateFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR) {
        cstrs.push_back("device address capture replay");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkFramebufferCreateFlagBits. Should be safe to static_cast between.
 */
enum class FramebufferCreateFlag {
    imglss = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
};

constexpr std::string frmbff_create_flag_str(FramebufferCreateFlag val)
{
    using enum FramebufferCreateFlag;

    switch(val) {
    case imglss:
        return "imageless";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string frmbff_create_flag_str(VkFramebufferCreateFlagBits val)
{
    return frmbff_create_flag_str(static_cast<FramebufferCreateFlag>(val));
}

using FramebufferCreateFlags = VkFramebufferCreateFlags;

constexpr std::vector<const char*> frmbff_create_flags_cstrs(VkFramebufferCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT) {
        cstrs.push_back("imageless");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPipelineCreationFeedbackFlagBits. Should be safe to static_cast between.
 */
enum class PipelineCreationFeedbackFlag {
    valid = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
    applctn_pplne_cache_hit = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
    base_pplne_acclrtn = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
};

constexpr std::string pplne_crtn_fdbck_flag_str(PipelineCreationFeedbackFlag val)
{
    using enum PipelineCreationFeedbackFlag;

    switch(val) {
    case valid:
        return "valid";
    case applctn_pplne_cache_hit:
        return "application pipeline cache hit";
    case base_pplne_acclrtn:
        return "base pipeline acceleration";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string pplne_crtn_fdbck_flag_str(VkPipelineCreationFeedbackFlagBits val)
{
    return pplne_crtn_fdbck_flag_str(static_cast<PipelineCreationFeedbackFlag>(val));
}

using PipelineCreationFeedbackFlags = VkPipelineCreationFeedbackFlags;

constexpr std::vector<const char*> pplne_crtn_fdbck_flags_cstrs(VkPipelineCreationFeedbackFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT) {
        cstrs.push_back("valid");
    }

    if (vals & VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT) {
        cstrs.push_back("application pipeline cache hit");
    }

    if (vals & VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT) {
        cstrs.push_back("base pipeline acceleration");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkPerformanceCounterDescriptionFlagBitsKHR. Should be safe to static_cast between.
 */
enum class PerformanceCounterDescriptionFlag {
    prfrmn_impctn = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
    cncrrny_impctd = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
};

constexpr std::string prfrmn_cntr_dscrptn_flag_str(PerformanceCounterDescriptionFlag val)
{
    using enum PerformanceCounterDescriptionFlag;

    switch(val) {
    case prfrmn_impctn:
        return "performance impacting";
    case cncrrny_impctd:
        return "concurrently impacted";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string prfrmn_cntr_dscrptn_flag_str(VkPerformanceCounterDescriptionFlagBitsKHR val)
{
    return prfrmn_cntr_dscrptn_flag_str(static_cast<PerformanceCounterDescriptionFlag>(val));
}

using PerformanceCounterDescriptionFlags = VkPerformanceCounterDescriptionFlagsKHR;

constexpr std::vector<const char*> prfrmn_cntr_dscrptn_flags_cstrs(VkPerformanceCounterDescriptionFlagsKHR vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR) {
        cstrs.push_back("performance impacting");
    }

    if (vals & VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR) {
        cstrs.push_back("concurrently impacted");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkToolPurposeFlagBits. Should be safe to static_cast between.
 */
enum class ToolPurposeFlag {
    vldtn = VK_TOOL_PURPOSE_VALIDATION_BIT,
    prflng = VK_TOOL_PURPOSE_PROFILING_BIT,
    trcng = VK_TOOL_PURPOSE_TRACING_BIT,
    addtnl_ftrs = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
    mdfyng_ftrs = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
};

constexpr std::string tool_prpse_flag_str(ToolPurposeFlag val)
{
    using enum ToolPurposeFlag;

    switch(val) {
    case vldtn:
        return "validation";
    case prflng:
        return "profiling";
    case trcng:
        return "tracing";
    case addtnl_ftrs:
        return "additional features";
    case mdfyng_ftrs:
        return "modifying features";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string tool_prpse_flag_str(VkToolPurposeFlagBits val)
{
    return tool_prpse_flag_str(static_cast<ToolPurposeFlag>(val));
}

using ToolPurposeFlags = VkToolPurposeFlags;

constexpr std::vector<const char*> tool_prpse_flags_cstrs(VkToolPurposeFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_TOOL_PURPOSE_VALIDATION_BIT) {
        cstrs.push_back("validation");
    }

    if (vals & VK_TOOL_PURPOSE_PROFILING_BIT) {
        cstrs.push_back("profiling");
    }

    if (vals & VK_TOOL_PURPOSE_TRACING_BIT) {
        cstrs.push_back("tracing");
    }

    if (vals & VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT) {
        cstrs.push_back("additional features");
    }

    if (vals & VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT) {
        cstrs.push_back("modifying features");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkSubmitFlagBits. Should be safe to static_cast between.
 */
enum class SubmitFlag {
    prtctd = VK_SUBMIT_PROTECTED_BIT,
};

constexpr std::string submit_flag_str(SubmitFlag val)
{
    using enum SubmitFlag;

    switch(val) {
    case prtctd:
        return "protected";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string submit_flag_str(VkSubmitFlagBits val)
{
    return submit_flag_str(static_cast<SubmitFlag>(val));
}

using SubmitFlags = VkSubmitFlags;

constexpr std::vector<const char*> submit_flags_cstrs(VkSubmitFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_SUBMIT_PROTECTED_BIT) {
        cstrs.push_back("protected");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkEventCreateFlagBits. Should be safe to static_cast between.
 */
enum class EventCreateFlag {
    device_only = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
};

constexpr std::string event_create_flag_str(EventCreateFlag val)
{
    using enum EventCreateFlag;

    switch(val) {
    case device_only:
        return "device only";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string event_create_flag_str(VkEventCreateFlagBits val)
{
    return event_create_flag_str(static_cast<EventCreateFlag>(val));
}

using EventCreateFlags = VkEventCreateFlags;

constexpr std::vector<const char*> event_create_flags_cstrs(VkEventCreateFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_EVENT_CREATE_DEVICE_ONLY_BIT) {
        cstrs.push_back("device only");
    }

    return cstrs;
}

/*!
 * \brief Maps to VkRenderingFlagBits. Should be safe to static_cast between.
 */
enum class RenderingFlag {
    cntnts_scndry_cmmnd_bffrs = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
    sspndn = VK_RENDERING_SUSPENDING_BIT,
    rsmng = VK_RENDERING_RESUMING_BIT,
};

constexpr std::string rndrng_flag_str(RenderingFlag val)
{
    using enum RenderingFlag;

    switch(val) {
    case cntnts_scndry_cmmnd_bffrs:
        return "contents secondary command buffers";
    case sspndn:
        return "suspending";
    case rsmng:
        return "resuming";
    default:
        return std::to_string(static_cast<int>(val));
    }
}

constexpr std::string rndrng_flag_str(VkRenderingFlagBits val)
{
    return rndrng_flag_str(static_cast<RenderingFlag>(val));
}

using RenderingFlags = VkRenderingFlags;

constexpr std::vector<const char*> rndrng_flags_cstrs(VkRenderingFlags vals)
{
    std::vector<const char*> cstrs;

    if (vals & VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT) {
        cstrs.push_back("contents secondary command buffers");
    }

    if (vals & VK_RENDERING_SUSPENDING_BIT) {
        cstrs.push_back("suspending");
    }

    if (vals & VK_RENDERING_RESUMING_BIT) {
        cstrs.push_back("resuming");
    }

    return cstrs;
}

} // namespace vk

constexpr VkImageLayout v(vk::ImageLayout t)
{
    return static_cast<VkImageLayout>(t);
}

constexpr VkAttachmentLoadOp v(vk::AttachmentLoadOp t)
{
    return static_cast<VkAttachmentLoadOp>(t);
}

constexpr VkAttachmentStoreOp v(vk::AttachmentStoreOp t)
{
    return static_cast<VkAttachmentStoreOp>(t);
}

constexpr VkImageType v(vk::ImageType t)
{
    return static_cast<VkImageType>(t);
}

constexpr VkImageTiling v(vk::ImageTiling t)
{
    return static_cast<VkImageTiling>(t);
}

constexpr VkImageViewType v(vk::ImageViewType t)
{
    return static_cast<VkImageViewType>(t);
}

constexpr VkCommandBufferLevel v(vk::CommandBufferLevel t)
{
    return static_cast<VkCommandBufferLevel>(t);
}

constexpr VkComponentSwizzle v(vk::ComponentSwizzle t)
{
    return static_cast<VkComponentSwizzle>(t);
}

constexpr VkDescriptorType v(vk::DescriptorType t)
{
    return static_cast<VkDescriptorType>(t);
}

constexpr VkQueryType v(vk::QueryType t)
{
    return static_cast<VkQueryType>(t);
}

constexpr VkBorderColor v(vk::BorderColor t)
{
    return static_cast<VkBorderColor>(t);
}

constexpr VkPipelineBindPoint v(vk::PipelineBindPoint t)
{
    return static_cast<VkPipelineBindPoint>(t);
}

constexpr VkPipelineCacheHeaderVersion v(vk::PipelineCacheHeaderVersion t)
{
    return static_cast<VkPipelineCacheHeaderVersion>(t);
}

constexpr VkPrimitiveTopology v(vk::PrimitiveTopology t)
{
    return static_cast<VkPrimitiveTopology>(t);
}

constexpr VkSharingMode v(vk::SharingMode t)
{
    return static_cast<VkSharingMode>(t);
}

constexpr VkIndexType v(vk::IndexType t)
{
    return static_cast<VkIndexType>(t);
}

constexpr VkFilter v(vk::Filter t)
{
    return static_cast<VkFilter>(t);
}

constexpr VkSamplerMipmapMode v(vk::SamplerMipmapMode t)
{
    return static_cast<VkSamplerMipmapMode>(t);
}

constexpr VkSamplerAddressMode v(vk::SamplerAddressMode t)
{
    return static_cast<VkSamplerAddressMode>(t);
}

constexpr VkCompareOp v(vk::CompareOp t)
{
    return static_cast<VkCompareOp>(t);
}

constexpr VkPolygonMode v(vk::PolygonMode t)
{
    return static_cast<VkPolygonMode>(t);
}

constexpr VkFrontFace v(vk::FrontFace t)
{
    return static_cast<VkFrontFace>(t);
}

constexpr VkBlendFactor v(vk::BlendFactor t)
{
    return static_cast<VkBlendFactor>(t);
}

constexpr VkBlendOp v(vk::BlendOp t)
{
    return static_cast<VkBlendOp>(t);
}

constexpr VkStencilOp v(vk::StencilOp t)
{
    return static_cast<VkStencilOp>(t);
}

constexpr VkLogicOp v(vk::LogicOp t)
{
    return static_cast<VkLogicOp>(t);
}

constexpr VkInternalAllocationType v(vk::InternalAllocationType t)
{
    return static_cast<VkInternalAllocationType>(t);
}

constexpr VkSystemAllocationScope v(vk::SystemAllocationScope t)
{
    return static_cast<VkSystemAllocationScope>(t);
}

constexpr VkPhysicalDeviceType v(vk::PhysicalDeviceType t)
{
    return static_cast<VkPhysicalDeviceType>(t);
}

constexpr VkVertexInputRate v(vk::VertexInputRate t)
{
    return static_cast<VkVertexInputRate>(t);
}

constexpr VkFormat v(vk::Format t)
{
    return static_cast<VkFormat>(t);
}

constexpr VkStructureType v(vk::StructureType t)
{
    return static_cast<VkStructureType>(t);
}

constexpr VkSubpassContents v(vk::SubpassContents t)
{
    return static_cast<VkSubpassContents>(t);
}

constexpr VkResult v(vk::Result t)
{
    return static_cast<VkResult>(t);
}

constexpr VkDynamicState v(vk::DynamicState t)
{
    return static_cast<VkDynamicState>(t);
}

constexpr VkDescriptorUpdateTemplateType v(vk::DescriptorUpdateTemplateType t)
{
    return static_cast<VkDescriptorUpdateTemplateType>(t);
}

constexpr VkObjectType v(vk::ObjectType t)
{
    return static_cast<VkObjectType>(t);
}

constexpr VkSemaphoreType v(vk::SemaphoreType t)
{
    return static_cast<VkSemaphoreType>(t);
}

constexpr VkPresentModeKHR v(vk::PresentMode t)
{
    return static_cast<VkPresentModeKHR>(t);
}

constexpr VkColorSpaceKHR v(vk::ColorSpace t)
{
    return static_cast<VkColorSpaceKHR>(t);
}

constexpr VkPointClippingBehavior v(vk::PointClippingBehavior t)
{
    return static_cast<VkPointClippingBehavior>(t);
}

constexpr VkSamplerReductionMode v(vk::SamplerReductionMode t)
{
    return static_cast<VkSamplerReductionMode>(t);
}

constexpr VkTessellationDomainOrigin v(vk::TessellationDomainOrigin t)
{
    return static_cast<VkTessellationDomainOrigin>(t);
}

constexpr VkSamplerYcbcrModelConversion v(vk::SamplerYcbcrModelConversion t)
{
    return static_cast<VkSamplerYcbcrModelConversion>(t);
}

constexpr VkSamplerYcbcrRange v(vk::SamplerYcbcrRange t)
{
    return static_cast<VkSamplerYcbcrRange>(t);
}

constexpr VkChromaLocation v(vk::ChromaLocation t)
{
    return static_cast<VkChromaLocation>(t);
}

constexpr VkQueueGlobalPriorityKHR v(vk::QueueGlobalPriority t)
{
    return static_cast<VkQueueGlobalPriorityKHR>(t);
}

constexpr VkVendorId v(vk::VendorId t)
{
    return static_cast<VkVendorId>(t);
}

constexpr VkDriverId v(vk::DriverId t)
{
    return static_cast<VkDriverId>(t);
}

constexpr VkCopyAccelerationStructureModeKHR v(vk::CopyAccelerationStructureMode t)
{
    return static_cast<VkCopyAccelerationStructureModeKHR>(t);
}

constexpr VkBuildAccelerationStructureModeKHR v(vk::BuildAccelerationStructureMode t)
{
    return static_cast<VkBuildAccelerationStructureModeKHR>(t);
}

constexpr VkAccelerationStructureTypeKHR v(vk::AccelerationStructureType t)
{
    return static_cast<VkAccelerationStructureTypeKHR>(t);
}

constexpr VkGeometryTypeKHR v(vk::GeometryType t)
{
    return static_cast<VkGeometryTypeKHR>(t);
}

constexpr VkAccelerationStructureBuildTypeKHR v(vk::AccelerationStructureBuildType t)
{
    return static_cast<VkAccelerationStructureBuildTypeKHR>(t);
}

constexpr VkRayTracingShaderGroupTypeKHR v(vk::RayTracingShaderGroupType t)
{
    return static_cast<VkRayTracingShaderGroupTypeKHR>(t);
}

constexpr VkAccelerationStructureCompatibilityKHR v(vk::AccelerationStructureCompatibility t)
{
    return static_cast<VkAccelerationStructureCompatibilityKHR>(t);
}

constexpr VkShaderGroupShaderKHR v(vk::ShaderGroupShader t)
{
    return static_cast<VkShaderGroupShaderKHR>(t);
}

constexpr VkPerformanceCounterScopeKHR v(vk::PerformanceCounterScope t)
{
    return static_cast<VkPerformanceCounterScopeKHR>(t);
}

constexpr VkPerformanceCounterUnitKHR v(vk::PerformanceCounterUnit t)
{
    return static_cast<VkPerformanceCounterUnitKHR>(t);
}

constexpr VkPerformanceCounterStorageKHR v(vk::PerformanceCounterStorage t)
{
    return static_cast<VkPerformanceCounterStorageKHR>(t);
}

constexpr VkShaderFloatControlsIndependence v(vk::ShaderFloatControlsIndependence t)
{
    return static_cast<VkShaderFloatControlsIndependence>(t);
}

constexpr VkPipelineExecutableStatisticFormatKHR v(vk::PipelineExecutableStatisticFormat t)
{
    return static_cast<VkPipelineExecutableStatisticFormatKHR>(t);
}

constexpr VkFragmentShadingRateCombinerOpKHR v(vk::FragmentShadingRateCombinerOp t)
{
    return static_cast<VkFragmentShadingRateCombinerOpKHR>(t);
}

constexpr vk::PipelineCacheCreateFlags flgs(vk::PipelineCacheCreateFlag t)
{
    return static_cast<vk::PipelineCacheCreateFlags>(t);
}

constexpr vk::QueueFlags flgs(vk::QueueFlag t)
{
    return static_cast<vk::QueueFlags>(t);
}

constexpr vk::CullModeFlags flgs(vk::CullModeFlag t)
{
    return static_cast<vk::CullModeFlags>(t);
}

constexpr vk::DeviceQueueCreateFlags flgs(vk::DeviceQueueCreateFlag t)
{
    return static_cast<vk::DeviceQueueCreateFlags>(t);
}

constexpr vk::MemoryPropertyFlags flgs(vk::MemoryPropertyFlag t)
{
    return static_cast<vk::MemoryPropertyFlags>(t);
}

constexpr vk::MemoryHeapFlags flgs(vk::MemoryHeapFlag t)
{
    return static_cast<vk::MemoryHeapFlags>(t);
}

constexpr vk::AccessFlags flgs(vk::AccessFlag t)
{
    return static_cast<vk::AccessFlags>(t);
}

constexpr vk::BufferUsageFlags flgs(vk::BufferUsageFlag t)
{
    return static_cast<vk::BufferUsageFlags>(t);
}

constexpr vk::BufferCreateFlags flgs(vk::BufferCreateFlag t)
{
    return static_cast<vk::BufferCreateFlags>(t);
}

constexpr vk::ShaderStageFlags flgs(vk::ShaderStageFlag t)
{
    return static_cast<vk::ShaderStageFlags>(t);
}

constexpr vk::ImageUsageFlags flgs(vk::ImageUsageFlag t)
{
    return static_cast<vk::ImageUsageFlags>(t);
}

constexpr vk::ImageCreateFlags flgs(vk::ImageCreateFlag t)
{
    return static_cast<vk::ImageCreateFlags>(t);
}

constexpr vk::PipelineCreateFlags flgs(vk::PipelineCreateFlag t)
{
    return static_cast<vk::PipelineCreateFlags>(t);
}

constexpr vk::PipelineShaderStageCreateFlags flgs(vk::PipelineShaderStageCreateFlag t)
{
    return static_cast<vk::PipelineShaderStageCreateFlags>(t);
}

constexpr vk::ColorComponentFlags flgs(vk::ColorComponentFlag t)
{
    return static_cast<vk::ColorComponentFlags>(t);
}

constexpr vk::FenceCreateFlags flgs(vk::FenceCreateFlag t)
{
    return static_cast<vk::FenceCreateFlags>(t);
}

constexpr vk::FormatFeatureFlags flgs(vk::FormatFeatureFlag t)
{
    return static_cast<vk::FormatFeatureFlags>(t);
}

constexpr vk::QueryControlFlags flgs(vk::QueryControlFlag t)
{
    return static_cast<vk::QueryControlFlags>(t);
}

constexpr vk::CommandBufferUsageFlags flgs(vk::CommandBufferUsageFlag t)
{
    return static_cast<vk::CommandBufferUsageFlags>(t);
}

constexpr vk::QueryPipelineStatisticFlags flgs(vk::QueryPipelineStatisticFlag t)
{
    return static_cast<vk::QueryPipelineStatisticFlags>(t);
}

constexpr vk::ImageAspectFlags flgs(vk::ImageAspectFlag t)
{
    return static_cast<vk::ImageAspectFlags>(t);
}

constexpr vk::SparseImageFormatFlags flgs(vk::SparseImageFormatFlag t)
{
    return static_cast<vk::SparseImageFormatFlags>(t);
}

constexpr vk::SparseMemoryBindFlags flgs(vk::SparseMemoryBindFlag t)
{
    return static_cast<vk::SparseMemoryBindFlags>(t);
}

constexpr vk::PipelineStageFlags flgs(vk::PipelineStageFlag t)
{
    return static_cast<vk::PipelineStageFlags>(t);
}

constexpr vk::CommandPoolCreateFlags flgs(vk::CommandPoolCreateFlag t)
{
    return static_cast<vk::CommandPoolCreateFlags>(t);
}

constexpr vk::CommandPoolResetFlags flgs(vk::CommandPoolResetFlag t)
{
    return static_cast<vk::CommandPoolResetFlags>(t);
}

constexpr vk::CommandBufferResetFlags flgs(vk::CommandBufferResetFlag t)
{
    return static_cast<vk::CommandBufferResetFlags>(t);
}

constexpr vk::SampleCountFlags flgs(vk::SampleCountFlag t)
{
    return static_cast<vk::SampleCountFlags>(t);
}

constexpr vk::AttachmentDescriptionFlags flgs(vk::AttachmentDescriptionFlag t)
{
    return static_cast<vk::AttachmentDescriptionFlags>(t);
}

constexpr vk::StencilFaceFlags flgs(vk::StencilFaceFlag t)
{
    return static_cast<vk::StencilFaceFlags>(t);
}

constexpr vk::DescriptorPoolCreateFlags flgs(vk::DescriptorPoolCreateFlag t)
{
    return static_cast<vk::DescriptorPoolCreateFlags>(t);
}

constexpr vk::DependencyFlags flgs(vk::DependencyFlag t)
{
    return static_cast<vk::DependencyFlags>(t);
}

constexpr vk::SemaphoreWaitFlags flgs(vk::SemaphoreWaitFlag t)
{
    return static_cast<vk::SemaphoreWaitFlags>(t);
}

constexpr vk::DisplayPlaneAlphaFlags flgs(vk::DisplayPlaneAlphaFlag t)
{
    return static_cast<vk::DisplayPlaneAlphaFlags>(t);
}

constexpr vk::CompositeAlphaFlags flgs(vk::CompositeAlphaFlag t)
{
    return static_cast<vk::CompositeAlphaFlags>(t);
}

constexpr vk::SurfaceTransformFlags flgs(vk::SurfaceTransformFlag t)
{
    return static_cast<vk::SurfaceTransformFlags>(t);
}

constexpr vk::SubgroupFeatureFlags flgs(vk::SubgroupFeatureFlag t)
{
    return static_cast<vk::SubgroupFeatureFlags>(t);
}

constexpr vk::DescriptorSetLayoutCreateFlags flgs(vk::DescriptorSetLayoutCreateFlag t)
{
    return static_cast<vk::DescriptorSetLayoutCreateFlags>(t);
}

constexpr vk::ExternalMemoryHandleTypeFlags flgs(vk::ExternalMemoryHandleTypeFlag t)
{
    return static_cast<vk::ExternalMemoryHandleTypeFlags>(t);
}

constexpr vk::ExternalMemoryFeatureFlags flgs(vk::ExternalMemoryFeatureFlag t)
{
    return static_cast<vk::ExternalMemoryFeatureFlags>(t);
}

constexpr vk::ExternalSemaphoreHandleTypeFlags flgs(vk::ExternalSemaphoreHandleTypeFlag t)
{
    return static_cast<vk::ExternalSemaphoreHandleTypeFlags>(t);
}

constexpr vk::ExternalSemaphoreFeatureFlags flgs(vk::ExternalSemaphoreFeatureFlag t)
{
    return static_cast<vk::ExternalSemaphoreFeatureFlags>(t);
}

constexpr vk::SemaphoreImportFlags flgs(vk::SemaphoreImportFlag t)
{
    return static_cast<vk::SemaphoreImportFlags>(t);
}

constexpr vk::ExternalFenceHandleTypeFlags flgs(vk::ExternalFenceHandleTypeFlag t)
{
    return static_cast<vk::ExternalFenceHandleTypeFlags>(t);
}

constexpr vk::ExternalFenceFeatureFlags flgs(vk::ExternalFenceFeatureFlag t)
{
    return static_cast<vk::ExternalFenceFeatureFlags>(t);
}

constexpr vk::FenceImportFlags flgs(vk::FenceImportFlag t)
{
    return static_cast<vk::FenceImportFlags>(t);
}

constexpr vk::PeerMemoryFeatureFlags flgs(vk::PeerMemoryFeatureFlag t)
{
    return static_cast<vk::PeerMemoryFeatureFlags>(t);
}

constexpr vk::MemoryAllocateFlags flgs(vk::MemoryAllocateFlag t)
{
    return static_cast<vk::MemoryAllocateFlags>(t);
}

constexpr vk::DeviceGroupPresentModeFlags flgs(vk::DeviceGroupPresentModeFlag t)
{
    return static_cast<vk::DeviceGroupPresentModeFlags>(t);
}

constexpr vk::DescriptorBindingFlags flgs(vk::DescriptorBindingFlag t)
{
    return static_cast<vk::DescriptorBindingFlags>(t);
}

constexpr vk::ResolveModeFlags flgs(vk::ResolveModeFlag t)
{
    return static_cast<vk::ResolveModeFlags>(t);
}

constexpr vk::GeometryInstanceFlags flgs(vk::GeometryInstanceFlag t)
{
    return static_cast<vk::GeometryInstanceFlags>(t);
}

constexpr vk::GeometryFlags flgs(vk::GeometryFlag t)
{
    return static_cast<vk::GeometryFlags>(t);
}

constexpr vk::BuildAccelerationStructureFlags flgs(vk::BuildAccelerationStructureFlag t)
{
    return static_cast<vk::BuildAccelerationStructureFlags>(t);
}

constexpr vk::AccelerationStructureCreateFlags flgs(vk::AccelerationStructureCreateFlag t)
{
    return static_cast<vk::AccelerationStructureCreateFlags>(t);
}

constexpr vk::FramebufferCreateFlags flgs(vk::FramebufferCreateFlag t)
{
    return static_cast<vk::FramebufferCreateFlags>(t);
}

constexpr vk::PipelineCreationFeedbackFlags flgs(vk::PipelineCreationFeedbackFlag t)
{
    return static_cast<vk::PipelineCreationFeedbackFlags>(t);
}

constexpr vk::PerformanceCounterDescriptionFlags flgs(vk::PerformanceCounterDescriptionFlag t)
{
    return static_cast<vk::PerformanceCounterDescriptionFlags>(t);
}

constexpr vk::ToolPurposeFlags flgs(vk::ToolPurposeFlag t)
{
    return static_cast<vk::ToolPurposeFlags>(t);
}

constexpr vk::SubmitFlags flgs(vk::SubmitFlag t)
{
    return static_cast<vk::SubmitFlags>(t);
}

constexpr vk::EventCreateFlags flgs(vk::EventCreateFlag t)
{
    return static_cast<vk::EventCreateFlags>(t);
}

constexpr vk::RenderingFlags flgs(vk::RenderingFlag t)
{
    return static_cast<vk::RenderingFlags>(t);
}

} // namespace cu

#endif
